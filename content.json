{"meta":{"title":"独ǒ无②'s blog","subtitle":"独ǒ无② 的技术小黑屋","description":null,"author":"独ǒ无②","url":"http://pvphero.github.io"},"pages":[],"posts":[{"title":"模板解题 NSum","slug":"20200518Sum","date":"2020-12-03T02:58:54.000Z","updated":"2020-12-03T05:24:00.532Z","comments":true,"path":"2020/12/03/20200518Sum/","link":"","permalink":"http://pvphero.github.io/2020/12/03/20200518Sum/","excerpt":"LeetCode 第一题就是很经典的题目： twoSum ，twoSum 的解法有很多种，最经典的方法就是 排序+双指针 ，如果我们掌握了这个核心解法，那么去解 NSum 的问题将会很easy！ 划重点 排序+双指针 是我们解决 NSum 的核心思想。","text":"LeetCode 第一题就是很经典的题目： twoSum ，twoSum 的解法有很多种，最经典的方法就是 排序+双指针 ，如果我们掌握了这个核心解法，那么去解 NSum 的问题将会很easy！ 划重点 排序+双指针 是我们解决 NSum 的核心思想。 一. twoSum 问题 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 这倒提的解法可以看我的 Github Day1120TowNum 由于这道题是让求数组的下标，跟我们要求数组里面的值相加等于target有点出入，所以这里不展开描述了。项目里面提供了两个解法，一个是利用HashMap去解，另一个是利用 排序+双指针 思路去解。 下面我们将题目描述变一下： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的 值。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [2, 7] 解决这个问题的核心是使用排序+双指针： 首先对数组进行排序 利用双指针，从两端相向相加跟target的值进行比较 问题的关键在于不能重复，假如数组为 [2, 7, 11, 15] ,target = 9 ,那么输出 [2,7],[7,2] 就是重复的项，所以我们需要注意将重复的值去掉。如果数组为[2, 7, 2, 7, 11, 15] ,target = 9 ,那么输出的 [2,7],[2,7] 也属于重复的项，同样需要将重复的项去掉。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public static List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int start, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //1.排序 Arrays.sort(nums); //2.定义两个指针 low heigh int low = start, heigh = nums.length - 1; while (low &lt; heigh) &#123; int sum = nums[low] + nums[heigh]; //3.定义两个临时变量用来存储 当前两个指针的值 left 跟 right int left = nums[low], right = nums[heigh]; if (sum &lt; target) &#123; //受4的启发 跳过所有重复的元素 while (low &lt; heigh &amp;&amp; nums[low] == left) &#123; low++; &#125; &#125; else if (sum &gt; target) &#123; //受4的启发 跳过所有重复的元素 while (low &lt; heigh &amp;&amp; nums[heigh] == right) &#123; heigh--; &#125; &#125; else &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(left); list.add(right); result.add(list); //4.跳过所有重复的元素 while (low &lt; heigh &amp;&amp; nums[low] == left) &#123; low++; &#125; while (low &lt; heigh &amp;&amp; nums[heigh] == right) &#123; heigh--; &#125; &#125; &#125; return result; &#125; ``` 这样我们就写出来一个通用的 `twoSum` 模板了，针对题目变种后，问题将会迎刃而解。- 时间复杂度： 循环是O(N)，排序是O(NlogN),所以整体的时间复杂度是 O(NlogN)# 二. `3Sum` 问题题目描述：&gt; 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。问题上升到 `3Sum` ,其实我们只有将这个问题转化成 `twoSum`,问题就会迎刃而解，怎么转换呢？**穷举**。我们求三个数的和是 `target`，那么也就是说我们可以固定住第一个数，然后去求除第一个数以外的其他数任选两个数的和为 `target-num[0]` ，依次类推，就是求`target-num[i]` 的 `twoSum`。所以代码如下：```java public static List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int start, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); //左指针改成 start，其他不变 int low = start, heigh = nums.length - 1; while (low &lt; heigh) &#123; ... &#125; return result; &#125; public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums, int start, int target) &#123; Arrays.sort(nums); int n = nums.length; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = start; i &lt; nums.length; i++) &#123; List&lt;List&lt;Integer&gt;&gt; listData = twoSum(nums, i + 1, target - nums[i]); for (List&lt;Integer&gt; data : listData) &#123; data.add(nums[i]); result.add(data); &#125; //跳出第一个数字重复的情况 while (i &lt; n - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123; i++; &#125; &#125; return result; &#125; 时间复杂度 排序O(NlogN),twoSum O(N), threeSum 里面循环调用twoSum，所以时间复杂度是 O(NlogN+N*N)=O(N^2) 4Sum 问题题目描述： 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/4sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决 4Sum 的思路跟解决 3Sum 的思路一样，我们通过穷举将问题转换成 3Sum ，问题就得到了解决。 代码如下： 123456789101112131415161718192021222324252627282930public static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); int n = nums.length; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; List&lt;List&lt;Integer&gt;&gt; listData = threeSum(nums, i + 1, target - nums[i]); for (List&lt;Integer&gt; data : listData) &#123; data.add(nums[i]); result.add(data); &#125; while (i &lt; n - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123; i++; &#125; &#125; return result; &#125; public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums, int start, int target) &#123; Arrays.sort(nums); int n = nums.length; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // i的起始值改为start，其他保持不变 for (int i = start; i &lt; nums.length; i++) &#123; ... &#125; return result; &#125; 时间复杂度： 4Sum 循环了 3Sum ，所以时间复杂度是 O(N^3) NSum 问题5Sum 根据 4Sum 可以得出，4Sum 根据 3Sum 可以得出，3Sum 根据 2Sum 可以得出，所以那就 递归 吧。。。 递归条件 nums ,n,start,target 递归终止条件 n如果小于2则退出递归 所以代码大概的递归框架如下： 1234567891011121314public static List&lt;List&lt;Integer&gt;&gt; nSum(int[] nums, int n, int start, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //递归结束条件 if(n&lt;2)&#123; return result; &#125; if(n==2)&#123; // twoSum &#125;else &#123; //递归逻辑 &#125;&#125; 我们现在根据递归框架，往代码里面进行填肉： 12345678910111213141516171819202122232425262728public static List&lt;List&lt;Integer&gt;&gt; nSum(int[] nums, int n, int start, int target) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //递归结束条件 int sz=nums.length; if (n &lt; 2) &#123; return result; &#125; if (n == 2) &#123; // twoSum result = twoSum(nums, start, target); &#125; else &#123; //当n&gt;2 时,递归计算 (n-1)Sum的结果 for (int i = start; i &lt; nums.length; i++) &#123; List&lt;List&lt;Integer&gt;&gt; lists = nSum(nums, n - 1, i + 1, target - nums[i]); for (List&lt;Integer&gt; data : lists) &#123; data.add(nums[i]); result.add(data); &#125; while (i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123; i++; &#125; &#125; &#125; return result; &#125; 总结总结一下：NSum 的核心思想就是 排序+双指针 ，当然我们为了求 NSum ，最后用到了递归。虽然方法不是最快的，但是这个思路是最方便解这样的题的。 参考资料 LeetCode labuladong题解","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://pvphero.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://pvphero.github.io/tags/算法/"}]},{"title":"重学Java--Java泛型","slug":"20200518JavaGeneric","date":"2020-05-18T09:08:54.000Z","updated":"2020-05-18T09:48:58.480Z","comments":true,"path":"2020/05/18/20200518JavaGeneric/","link":"","permalink":"http://pvphero.github.io/2020/05/18/20200518JavaGeneric/","excerpt":"1.为什么我们需要泛型？通过两端代码我们就可以知道为什么需要泛型 1234567public int addInt(int x,int y)&#123; return x+y; &#125; public float addFloat(float x,float y)&#123; return x+y; &#125;","text":"1.为什么我们需要泛型？通过两端代码我们就可以知道为什么需要泛型 1234567public int addInt(int x,int y)&#123; return x+y; &#125; public float addFloat(float x,float y)&#123; return x+y; &#125; 以上例子，求两个数的和。现在已经有int类型的求和跟float类型的求和，但是如果要实现一个double类型的和，就需要重新写一个double的add方法。如下： 1234//doublepublic double addDouble(double x,double y)&#123; return x+y;&#125; 其实对于开发者来说，逻辑是一样的，只是参数不同，如果没有泛型，就需要重写类似的方法。 所以泛型的好处：适用于多种数据类型执行相同的代码。可以简化代码。 2.泛型类，泛型接口，泛型方法定义一个自己的泛型: 1.泛型类12345678910111213141516171819202122232425262728public class NormalGeneric&lt;K&gt; &#123; private K data; public NormalGeneric() &#123; &#125; public NormalGeneric(K data) &#123; this.data = data; &#125; public K getData() &#123; return data; &#125; public void setData(K data) &#123; this.data = data; &#125; public static void main(String[] args) &#123; NormalGeneric&lt;String&gt; normalGeneric = new NormalGeneric&lt;&gt;(); normalGeneric.setData(\"OK\"); //normalGeneric.setData(1); System.out.println(normalGeneric.getData()); NormalGeneric normalGeneric1 = new NormalGeneric(); normalGeneric1.setData(1); normalGeneric1.setData(\"dsf\"); &#125;&#125; 2.泛型接口123public interface Genertor&lt;T&gt; &#123; public T next();&#125; 实现泛型接口的实现类。 实现方式一： 123456public class ImplGenertor&lt;T&gt; implements Genertor&lt;T&gt; &#123; @Override public T next() &#123; return null; &#125;&#125; 实现方式二： 123456public class ImplGenertor2 implements Genertor&lt;String&gt; &#123; @Override public String next() &#123; return null; &#125; &#125; 可见，如果是泛型类实现泛型接口的话，那么返回值也是泛型。 3.泛型方法泛型方法是完全独立的 3.1 在普通类中的泛型方法代码如下：1234567891011121314151617public class GenericMethod &#123; public &lt;T&gt; T genericMethod(T...a)&#123; return a[a.length/2]; &#125; public void test(int x,int y)&#123; System.out.println(x+y); &#125; public static void main(String[] args) &#123; GenericMethod genericMethod = new GenericMethod(); genericMethod.test(23,343); System.out.println(genericMethod.&lt;String&gt;genericMethod(\"apple\",\"banana\")); System.out.println(genericMethod.genericMethod(12,34)); &#125;&#125; 3.2 在泛型类里面使用泛型方法：123456789101112131415161718192021public class GenericMethod2 &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125; &#125; public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; ... &#125; public static void main(String[] args) &#123; &#125;&#125; 上述代码中, 123public T getKey()&#123; return key;&#125; 虽然在方法中使用了泛型，但是这并不是一个泛型方法。这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。所以在这个方法中才可以继续使用 T 这个泛型。 123public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; ...&#125; 这才是一个真正的泛型方法。 小结1： 首先在public与返回值之间的必不可少，这表明这是一个泛型方法， 并且声明了一个泛型T_ 这个T可以出现在这个泛型方法的任意位置._ 泛型的数量也可以为任意多个 再看个代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GenericMethod3 &#123; static class Fruit&#123; @Override public String toString() &#123; return \"fruit\"; &#125; &#125; static class Apple extends Fruit&#123; @Override public String toString() &#123; return \"apple\"; &#125; &#125; static class Person&#123; @Override public String toString() &#123; return \"Person\"; &#125; &#125; static class GenerateTest&lt;T&gt;&#123; //普通方法 public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。 // 可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型， // 编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T， // 注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public static void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;&gt;(); generateTest.show_1(apple); //generateTest.show_1(person); generateTest.show_2(apple); generateTest.show_2(person); generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125; 小结2：泛型类里面定义泛型方法，参数可以完全不一样。上面的T影响泛型类的普通方法。但是对泛型方法没有影响。 3.如何限定类型变量比如计算两个变量的最小值，最大值。 但是怎么才能保证传入的变量一定有compareTo方法？为了解决这个问题，就引入了限定类型变量的泛型。代码如下： 1234567 public static &lt;T extends Comparable&gt; T min(T a, T b)&#123; if(a.compareTo(b)&gt;0) &#123; return a; &#125; else &#123; return b; &#125;&#125; T extends Comparable中T表示应该绑定类型的子类型，后面的Comparable表示绑定类型，子类型和绑定类型可以是类也可以是接口。 但是如果类跟接口混用的话，规则如下： 类只能有一个 并且类需要写到接口的前面 限定类型的泛型，对泛型类，泛型方法同样适用 代码如下： 1234public static &lt;T extends ArrayList &amp; Comparable&gt; T min(T a, T b) &#123; if (a.compareTo(b) &gt; 0) return a; else return b;&#125; 4.泛型使用中的约束和局限性假设我们有以下泛型类： 123public class Restrict&lt;T&gt; &#123; ...&#125; 不能用基本类型实例化类型参数 12345//错误代码示例//不能实例化类型变量 public Restrict() &#123; this.data = new T();&#125; 在静态域或者方法里面不能引用类型变量 123//错误代码示例//静态域或者方法里不能引用类型变量private static T instance; 先执行static方法 再执行构造方法 所以先执行static T，根本不知道T的类型，所以行不通 但是如果是静态方法本身是泛型方法是可以的 12//正确代码示例private static &lt;T&gt; T getInstance()&#123;&#125; 基础类型不允许做实例化参数的，例如：double不能用在泛型参数里，必须用double的包装类Double 错误的写法： 12 //错误代码示例Restrict&lt;double&gt; 正确的写法： 12//正确代码示例Restrict&lt;Double&gt; 泛型里面不允许使用instanceof 泛型中可以定义反省数组，但是不能创建参数化类型的数组 不能捕获泛型类的实例 但是如果把异常抛出来，是可以，如下： 小结： 不能用基本类型实例化类型参数。 在静态域或者方法里面不能引用类型变量。 基础类型不允许做实例化参数的，例如：double不能用在泛型参数里，必须用double的包装类Double。 泛型里面不允许使用instanceof。 泛型中可以定义反省数组，但是不能创建参数化类型的数组。 不能捕获泛型类的实例。 5.泛型类型能继承吗？例子如下： 12345678910public class Employee &#123; ....&#125;public class Worker extends Employee &#123;&#125;public class Pair&lt;T&gt; &#123; ...&#125; 1Pair&lt;Employee&gt; employeePair2 = new Pair&lt;Worker&gt;(); 会报错。但是，泛型类是可以继承或者扩展其他类的！ 1234/*泛型类可以继承或者扩展其他泛型类，比如List和ArrayList*/ private static class ExtendPair&lt;T&gt; extends Pair&lt;T&gt;&#123; &#125; 小结 泛型类无法协变的 泛型可以继承或者扩展其他的泛型类 6.泛型中的通配符类型现有如下类的派生关系： 代码如下: 12345678910111213141516//我们有如下方法和泛型类public static void print(GenericType&lt;Fruit&gt; p) &#123; System.out.println(p.getData().getColor());&#125;public class GenericType&lt;T&gt; &#123; private T data; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 12345678910111213141516171819public class Food &#123; ...&#125;public class Fruit extends Food &#123; ...&#125;public class Apple extends Fruit &#123; ...&#125;public class Orange extends Fruit &#123; ...&#125;public class HongFuShi extends Apple &#123; ...&#125; 但是使用的时候，print(b)是不允许的。正如之前提到的，Orange虽然是派生自Fruit，但是GenericType&lt;Orange&gt;和GenericType&lt;Fruit&gt;是没有任何关系的。 123456public static void use() &#123; GenericType&lt;Fruit&gt; a = new GenericType&lt;&gt;(); print(a); GenericType&lt;Orange&gt; b = new GenericType&lt;&gt;(); //print(b); 不允许 &#125; 所以为了解决泛型无法协变的问题的的问题，就引入了泛型通配符的概念。 1.协变指的就是Orange派生自Fruit，那么List也派生自List,但是泛型是不支持的。2.泛型T是确定的参数类型，一旦传了就定下来了，而通配符非常的灵活是不确定的类型，更多的情况用于扩充参数范围。3.通配符不是类型参数变量，通配符更像一种规定，规定你只能传哪些类型的参数。 就上述代码，我们想要print(b),可以这么做: 123public static void print2(GenericType&lt;? extends Fruit&gt; p) &#123; System.out.println(p.getData().getColor());&#125; 123456public static void use2() &#123; GenericType&lt;Fruit&gt; a = new GenericType&lt;&gt;(); print2(a); GenericType&lt;Orange&gt; b = new GenericType&lt;&gt;(); print2(b); &#125; 这里的？就是通配符。 6.1 上界通配符&lt;? extends T&gt;利用 &lt;? extends T&gt; 形式的通配符，可以实现泛型的向上转型。 1? extends Fruit 表示通配符的上界是Fruit GenericType&lt;? extends Fruit&gt; 代表一个可以持有Fruit 及其子类（如：Apple，Orange）的实例的GenericTyp对象。 6.1.1 如果？是Fruit的父类，会怎样？ 6.1.2 上界只能外围取，不能往里放GenericType&lt;T&gt; 方法中有getData()和setData()方法。 1234567891011public class GenericType&lt;T&gt; &#123; private T data; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 代码调用如下： 12345678public static void use2() &#123; GenericType&lt;? extends Fruit&gt; c = new GenericType&lt;&gt;(); Apple apple = new Apple(); Fruit fruit = new Fruit(); //c.setData(apple);//Error //c.setData(fruit);//Error Fruit x = c.getData(); &#125; 我们发现往水果里面设置水果类型的方法setData() 会失效，但是获取某种水果类型的getData() 方法还有效。 原因：? extends T 表示类型的上界，类型参数是T的子类或者他本身，那么可以肯定的说，get方法返回的一定是T，这个编译器是可以确定的。但是set方法只知道传入的是个T，具体是T还是T的哪个子类，编译器不能确定。 Java编译期只知道容器里面存放的是Fruit或者是Fruit的派生类，具体是什么类型，编译器并不知道。当编译器执行到 c.setData(apple) ，GenericType 并没有将值设置成apple，而是标记了一个占位符capture #1 ,用来表示编译器捕获到一个Fruit类或者他的派生类，具体什么类型不知道。所以在setdata() 的时候传入的Apple和Fruit，编译器不确定是否能跟之前标记的capture #1 匹配。getData() 方法，这个可以正常用其实就很好理解了，因为上界通配符只能往容器里面放Fruit类或者他的派生类，所以获取到的类都可以隐式转换为他们的基类(或者Object基类) 6.2 下界通配符&lt;? super T&gt;下界通配符只能往容器中放T或者T的基类类型的数据。&lt;? super Apple&gt; 代码如下： 123public static void printSuper(GenericType&lt;? super Apple&gt; p) &#123; System.out.println(p.getData()); &#125; 6.2.1 下界范围12345678910 public static void useSuper() &#123; GenericType&lt;Fruit&gt; fruitGenericType = new GenericType&lt;&gt;(); GenericType&lt;Apple&gt; appleGenericType = new GenericType&lt;&gt;(); GenericType&lt;HongFuShi&gt; hongFuShiGenericType = new GenericType&lt;&gt;(); GenericType&lt;Orange&gt; orangeGenericType = new GenericType&lt;&gt;(); printSuper(fruitGenericType); printSuper(appleGenericType);// printSuper(hongFuShiGenericType); //Error// printSuper(orangeGenericType); //Error &#125; printSuper(hongFuShiGenericType)和printSuper(orangeGenericType)就会在编译期报错，因为超过了通配符的下界。 6.2.2 下界不影响往里存，但往外取只能放在Object 对象里同样GenericType&lt;T&gt; 方法中有getData()和setData()方法。 1234567891011public class GenericType&lt;T&gt; &#123; private T data; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 代码调用如下： 123456789public static void useSuper() &#123; //表示GenericType的类型参数的下界是Apple GenericType&lt;? super Apple&gt; x = new GenericType&lt;&gt;(); x.setData(new Apple()); x.setData(new HongFuShi()); //x.setData(new Fruit()); // Error Object data = x.getData(); &#125; 我们发现setData()是可以正常调用的，getDat()方法返回了Object对象。但是为什么setData()的时候传入了Apple的父类，就会报错呢？以及为什么getData()只能用object来接收呢? 原因： ? super T ,表示的类型的下界，也就是说表示的是T的基类。所以我们实际上是不知道这个类到底是什么，但是肯定是T的超类或者他本身。 因此我们使用x.setData()的时候，如果set的类是T的子类或者T，那么他们可以安全的向上转型为T。所以我们x.setData()可以放T的子类或者T本身。对于T的基类，编译器并不知道这个类对象是否是安全的，所以在使用下界通配符的时候是不能直接添加T的基类。 我们在使用x.getData()的时候，返回的值一定是T的超类或者他本身，但是要转成哪个超类，编译器不知道，唯一可以确定的，Object是所有类的基类，所以只有转成Object才是安全的。这就是我们在使用getData()的时候必须使用Object来接收原因。 6.3 PECS PECS:Producer extends Consumer super （生产者使用extends，consumer使用super） 上界&lt;? extends T&gt;不能往里存，只能往外取(不能set，只能get)，适合频繁往外面读取内容的场景。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。 7.虚拟机如何实现泛型？ 泛型是JDK 1.5的一项新增特性，它的本质是参数化类型（Parametersized Type）的应用，Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。 看下面一个简单的泛型例子：例子1:我们有如下类： 123public class Apple extends Fruit &#123; ...&#125; 123public class Orange extends Fruit &#123; ...&#125; 12345public static void main(String[] args) &#123; ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;(); ArrayList&lt;Orange&gt; orange = new ArrayList&lt;&gt;(); System.out.println(apples.getClass() == orange.getClass()); &#125; 上述例子中，apples只能存Apple，orange中只能存Orange，最好我们通过xxx.getClass()方法来获取他们的类信息，最后结果发现为true。说明泛型类型Apple和Orange都被擦除了，只剩下原始类型。 例子2： 12345public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"Roy\",\"18\"); System.out.println(map.get(\"Roy\")); &#125; 把这段Java代码编译成Class文件，然后字节码反编译一下，发现所有的泛型都不见了。javac xxxx.java 12345public static void main(String[] var0) &#123; HashMap var1 = new HashMap(); var1.put(\"Roy\", \"18\"); System.out.println((String)var1.get(\"Roy\")); &#125; 待续。。。","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"http://pvphero.github.io/categories/Java学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://pvphero.github.io/tags/Java/"}]},{"title":"Android 开发如何进行单元测试","slug":"20191220AndroidUnitTest","date":"2019-12-23T09:08:54.000Z","updated":"2020-03-27T13:47:10.326Z","comments":true,"path":"2019/12/23/20191220AndroidUnitTest/","link":"","permalink":"http://pvphero.github.io/2019/12/23/20191220AndroidUnitTest/","excerpt":"什么是单元测试单元测试是由一组独立的测试构成，每个测试针对软件中的一个单独的程序单元。单元测试并非检查程序单元直接是否能够合作良好，而是检查单个程序单元的行为是否正确。 事实上，单元测试是一种验证行为，测试和验证程序中的每一项的正确性。","text":"什么是单元测试单元测试是由一组独立的测试构成，每个测试针对软件中的一个单独的程序单元。单元测试并非检查程序单元直接是否能够合作良好，而是检查单个程序单元的行为是否正确。 事实上，单元测试是一种验证行为，测试和验证程序中的每一项的正确性。 为什么要进行单元测试对于单元测试，人们往往存在很多误解： 浪费时间太多，本身项目的时间就很紧张，没有时间去写单元测试。 过度的依赖测试人员，认为软件开发人员不应该参与单元测试。 认为单元测试不必要，代码写得很好了，no bug，no warning。 老代码结构混乱，耦合度高，为了写单元测试修改代码结构，意义不大，投入跟产出不成比例。 单元测试真的这么鸡肋么？No，No，No！！！ 试想 测试人员给你报了一个bug，但是由于之后的merge失误导致代码丢失，或者别人修改代码导致这个bug再次复现。 重构代码的时候，被bug淹没。造成你持续不断的改bug，持续不断的加班。 明明很正常的功能，怎么现在突然不能用了？是接口的问题，还是有人修改了这个功能的逻辑？ 。。。 如果你也经常遇到这些困惑，那么你就需要对项目进行单元测试了。 因为单元测试具有以下优势： 帮助理解需求 单元测试应该反映Use Case，把被测单元当成黑盒测试其外部行为。 提高实现质量 单元测试不保证程序做正确的事，但能帮助保证程序正确地做事，从而提高实现质量。 测试成本低 相比集成测试、验收测试，单元测试所依赖的外部环境少，自动化程度高，时间短，节约了测试成本。 反馈速度快 单元测试提供快速反馈，把bug消灭在开发阶段，减少问题流到集成测试、验收测试和用户，降低了软件质量控制的成本。 利于重构 由于有单元测试作为回归测试用例，有助于预防在重构过程中引入bug。 文档作用 单元测试提供了被测单元的使用场景，起到了使用文档的作用。 对设计的反馈 一个模块很难进行单元测试通常是不良设计的信号，单元测试可以反过来指导设计出高内聚、低耦合的模块。 为什么要做单元测试？ 怎么进行单元测试Android 单元测试分类Android 单元测试分为两大类： 1234app/src ├── androidTestjava (Instrumented 单元测试、UI测试) ├── main/java (业务代码) └── test/java (Local 单元测试) Local test: 运行在本地的JVM虚拟机上，不依赖Android框架。 Instrumented tests: 通过Android系统的Instrumented测试框架，运行测试代码在真实手机上。 Android Junit + Mockito + Powermock单元测试方案Junit + Mockito + Powermock简介Junit 是一个Java语言的单元测试框架Mockito 是一个Mock框架，我们可以通过Mockito框架创建配置mock对象。Powermock 可以针对static，final，private方法进行mock Junit + Mockito + Powermock使用强烈建议你熟读以下内容，来熟悉Junit + Mockito + Powermock的使用。 Mockito 中文文档 ( 2.0.26 beta ) Mockito reference documentation powermock wiki Unit tests with Mockito - Tutorial 比如说我们要对Calculate类进行单元测试123456789101112131415161718192021222324252627282930313233343536373839public class Calculate &#123; private int mPrivate; private final int mPrivateFinal = 0; private static int mPrivateStatic = 0; private static final int mPrivateStaticFinal = 0; public int mPublic; public final int mPublicFinal = 0; public static int mPublicStatic = 0; public static final int mPublicStaticFinal = 0; public void voidPublicMethod(int a, int b) &#123; return; &#125; public int addPublicMethod(int a, int b) &#123; return a + b; &#125; private int addPrivateMethod(int a, int b) &#123; return a + b; &#125; public static int addPublicStaticMethod(int a, int b) &#123; return a + b; &#125; private static int addPrivateStaticMethod(int a, int b) &#123; return a + b; &#125;&#125; 测试Public 变量 1234567891011121314 @Testpublic void testPublicField() &#123; assertEquals(mCalculate.mPublic, 0); assertEquals(mCalculate.mPublicFinal, 0); assertEquals(Calculate.mPublicStatic, 0); assertEquals(Calculate.mPublicStaticFinal, 0); mCalculate.mPublic = 1; Calculate.mPublicStatic = 2; assertEquals(mCalculate.mPublic, 1); assertEquals(mCalculate.mPublicFinal, 0); assertEquals(Calculate.mPublicStatic, 2);&#125; 测试Public 方法 1234567891011121314151617181920 @Testpublic void testAddPublicMethod() &#123; //when when(mCalculate.addPublicMethod(anyInt(), anyInt())) .thenReturn(0) .thenReturn(1); //call method for (int i = 0; i &lt; 2; i++) &#123; //verify assertEquals(mCalculate.addPublicMethod(i, i), i); &#125; //verify verify(mCalculate, times(2)).addPublicMethod(anyInt(), anyInt()); verify(mCalculate, atLeast(1)).addPublicMethod(anyInt(), anyInt()); verify(mCalculate, atLeastOnce()).addPublicMethod(anyInt(), anyInt()); verify(mCalculate, atMost(2)).addPublicMethod(anyInt(), anyInt());&#125; 测试Public 返回Void 方法 123456@Testpublic void testAddPublicVoidMethod() &#123; //when doNothing().when(mCalculate).voidPublicMethod(anyInt(), anyInt());&#125; 测试Public Static 方法 12345678@Testpublic void testAddPublicStaicMethod() throws Exception &#123; PowerMockito.mockStatic(Calculate.class); PowerMockito.when(Calculate.class, \"addPublicStaticMethod\", anyInt(), anyInt()) .thenReturn(0) .thenReturn(1);&#125; 测试Private Static 变量 123456789101112131415161718 @Testpublic void testPrivate() throws IllegalAccessException &#123; PowerMockito.mockStatic(Calculate.class); assertEquals(Whitebox.getField(Calculate.class, \"mPrivate\").getInt(mCalculate), 0); assertEquals(Whitebox.getField(Calculate.class, \"mPrivateFinal\").getInt(mCalculate), 0); assertEquals(Whitebox.getField(Calculate.class, \"mPrivateStatic\").getInt(null), 0); assertEquals(Whitebox.getField(Calculate.class, \"mPrivateStaticFinal\").getInt(null), 0); Whitebox.setInternalState(mCalculate, \"mPrivate\", 1); Whitebox.setInternalState(Calculate.class, \"mPrivateStatic\", 1, Calculate.class); assertEquals(Whitebox.getField(Calculate.class, \"mPrivate\").getInt(mCalculate), 1); assertEquals(Whitebox.getField(Calculate.class, \"mPrivateFinal\").getInt(mCalculate), 0); assertEquals(Whitebox.getField(Calculate.class, \"mPrivateStatic\").getInt(null), 1); assertEquals(Whitebox.getField(Calculate.class, \"mPrivateStaticFinal\").getInt(null), 0);&#125; 测试Private 方法 12345678910 @Testpublic void testAddPrivateMethod() throws Exception &#123; PowerMockito.mockStatic(Calc.class); //when PowerMockito.when(mCalculate,\"addPrivateMethod\",anyInt(),anyInt()) .thenReturn(0) .thenReturn(1); &#125; 测试Private static 方法 12345678@Testpublic void testAddPrivateStaicMethod() throws Exception &#123; PowerMockito.mockStatic(Calculate.class); PowerMockito.when(Calculate.class, \"addPrivateStaticMethod\", anyInt(), anyInt()) .thenReturn(0) .thenReturn(1);&#125; 对单例进行mock比如对以下代码进行mock 1234567891011121314151617public class Singleton &#123; public String PUBLIC_STR = \"public_str\"; private static class ServiceSingleton &#123; private static final Singleton SINGLE = new Singleton(); &#125; public static Singleton get() &#123; return ServiceSingleton.SINGLE; &#125; public String getPublicStr() &#123; return PUBLIC_STR; &#125;&#125; 123456789101112131415public class SingletonUse &#123; private static final String PUBLIC_STR = \"public_str\"; private static class ServiceSingleton &#123; private static final SingletonUse SINGLE = new SingletonUse(); &#125; public static SingletonUse get() &#123; return ServiceSingleton.SINGLE; &#125; public String getUsePublicStr() &#123; return Singleton.get().getPublicStr(); &#125;&#125; 测试类 12345678910111213141516171819202122@RunWith(PowerMockRunner.class)@PrepareForTest(&#123;Singleton.class, SingletonUse.class&#125;)public class SingletonUseTest &#123; private SingletonUse singletonUse; @Before public void setUp() throws Exception &#123; Singleton singleton = PowerMockito.mock(Singleton.class); PowerMockito.mockStatic(Singleton.class); PowerMockito.doReturn(singleton).when(Singleton.class, \"get\"); singletonUse = PowerMockito.mock(SingletonUse.class); PowerMockito.mockStatic(SingletonUse.class); PowerMockito.doReturn(singletonUse).when(SingletonUse.class, \"get\"); &#125; @Test public void getUsePublicStr() throws Exception &#123; PowerMockito.doReturn(\"123456\").when(singletonUse,\"getUsePublicStr\"); &#125;&#125; 参考资料 Unit testing support junit4 mockito powermock 在Android Studio中进行单元测试和UI测试 Android单元测试只看这一篇就够了 代码覆盖率浅谈 PowerMock单元测试踩坑与总结","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android UnitTest","slug":"Android-UnitTest","permalink":"http://pvphero.github.io/tags/Android-UnitTest/"}]},{"title":"android-Camera2Basic 解析","slug":"20190123Camera2FragmentUse","date":"2019-01-23T09:08:54.000Z","updated":"2019-02-12T02:57:31.657Z","comments":true,"path":"2019/01/23/20190123Camera2FragmentUse/","link":"","permalink":"http://pvphero.github.io/2019/01/23/20190123Camera2FragmentUse/","excerpt":"Android Camera2介绍Android 5.0(API Level 21) 重新设计了 Camera，废弃了之前的 Camera，改用现在的 Camera2 API，在Camera2上引入了Session/Request的概念，使用的复杂度远超之前的 Camera。","text":"Android Camera2介绍Android 5.0(API Level 21) 重新设计了 Camera，废弃了之前的 Camera，改用现在的 Camera2 API，在Camera2上引入了Session/Request的概念，使用的复杂度远超之前的 Camera。 Camera2主要类简介 CameraManager：摄像头管理类，用于检测，打开系统摄像头，可以通过getCameraCharacteristics(cameraId)获取摄像头的特征 CameraCharacteristics：相机的特性类，可以得到相机是否支持自动对焦，是否支持闪光灯等特征 CameraDevice：相机设备类 CameraCaptureSession：用于创建预览，拍照的Session类。 CaptureRequest：相机的请求类，可以通过这个类获取一次捕获的请求，可以设置一些参数等。 CameraRequest和CameraRequest.Builder：当程序调用setRepeatingRequest()方法进行预览时，或调用capture()方法进行拍照时，都需要传入CameraRequest参数。CameraRequest代表了一次捕获请求，用于描述捕获图片的各种参数设置，比如对焦模式、曝光模式……总之，程序需要对照片所做的各种控制，都通过CameraRequest参数进行设置。CameraRequest.Builder则负责生成CameraRequest对象。 Camera2 API 基本架构 APP通过创建一个CaptureRequest向CameraDevice发起Capture请求 CameraDevice收到请求后返回对应数据的预览数据 点击拍照后，会从ImageReader中读取数据 CaptureRequest代表请求控制的Camera参数, CameraMetadata(CaptureResult)则表示当前返回帧中Camera使用的参数以及当前状态. 使用流程 初始化，打开Camera 通过 12345if (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123; requestCameraPermission(); return;&#125; 获取权限 通过 context.getSystemService(Context.CAMERA_SERVICE) 获取CameraManager 通过CameraManager.getCameraCharacteristics(cameraId)获取相机的摄像头的特性 SENSOR_ORIENTATION：获取摄像头的拍照的方向 LENS_FACING：获取摄像头的方向。LENS_FACING_FRONT是前摄像头，LENS_FACING_BACK是后摄像头。 获取FPS的范围 获取大小 调用CameraManager .open()方法在回调中得到CameraDevice. Create Session 通过CameraDevice.createCaptureSession()在回调中获取CameraCaptureSession. Config Session 构建CaptureRequest, 有三种模式可选 预览/拍照/录像. Capture 拍照数据可以在ImageReader.OnImageAvailableListener回调中获取, CaptureCallback中则可获取拍照实际的参数和Camera当前状态. android-Camera2Basic介绍android-Camera2Basic是谷歌官方给的Camera2的demo，演示了Camrea2 API的基本功能，通过这个Demo，我们可以掌握连接设备，显示预览，以及拍照的基本使用。 项目结构12345├── .DS_Store└── camera2basic ├── AutoFitTextureView.java ├── Camera2BasicFragment.java └── CameraActivity.java 代码详解打开相机，创建预览openCamera1234567891011121314151617181920212223private void openCamera(int width, int height) &#123; if (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123; //请求权限 requestCameraPermission(); return; &#125; //设置相机相关的参数 setUpCameraOutputs(width, height); configureTransform(width, height); Activity activity = getActivity(); CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE); try &#123; if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) &#123; throw new RuntimeException(\"Time out waiting to lock camera opening.\"); &#125; manager.openCamera(mCameraId, mStateCallback, mBackgroundHandler); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(\"Interrupted while trying to lock camera opening.\", e); &#125; &#125; setUpCameraOutputs(width, height)123456789101112131415161718192021222324252627282930313233343536@SuppressWarnings(\"SuspiciousNameCombination\") private void setUpCameraOutputs(int width, int height) &#123; Activity activity = getActivity(); CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE); try &#123; //获取摄像头可用列表 for (String cameraId : manager.getCameraIdList()) &#123; //获取相机的特性 CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId); // 不使用前置摄像头 Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING); if (facing != null &amp;&amp; facing == CameraCharacteristics.LENS_FACING_FRONT) &#123; continue; &#125; StreamConfigurationMap map = characteristics.get( CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP); if (map == null) &#123; continue; &#125; // For still image captures, we use the largest available size. Size largest = Collections.max( Arrays.asList(map.getOutputSizes(ImageFormat.JPEG)), new CompareSizesByArea()); //设置ImageReader接收的图片格式，以及允许接收的最大图片数目 mImageReader = ImageReader.newInstance(largest.getWidth(), largest.getHeight(), ImageFormat.JPEG, /*maxImages*/2); //设置图片存储的监听 mImageReader.setOnImageAvailableListener( mOnImageAvailableListener, mBackgroundHandler); ... &#125; CameraDevice.StateCallback监听123456789101112131415161718192021222324252627282930private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() &#123; @Override public void onOpened(@NonNull CameraDevice cameraDevice) &#123; // This method is called when the camera is opened. We start camera preview here. mCameraOpenCloseLock.release(); mCameraDevice = cameraDevice; //创建PreviewSession createCameraPreviewSession(); &#125; @Override public void onDisconnected(@NonNull CameraDevice cameraDevice) &#123; mCameraOpenCloseLock.release(); cameraDevice.close(); mCameraDevice = null; &#125; @Override public void onError(@NonNull CameraDevice cameraDevice, int error) &#123; mCameraOpenCloseLock.release(); cameraDevice.close(); mCameraDevice = null; Activity activity = getActivity(); if (null != activity) &#123; activity.finish(); &#125; &#125; &#125;; createCaptureSession1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void createCameraPreviewSession() &#123; try &#123; SurfaceTexture texture = mTextureView.getSurfaceTexture(); assert texture != null; // We configure the size of default buffer to be the size of camera preview we want. texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight()); // This is the output Surface we need to start preview. Surface surface = new Surface(texture); // We set up a CaptureRequest.Builder with the output Surface. mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewRequestBuilder.addTarget(surface); // Here, we create a CameraCaptureSession for camera preview. mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()), new CameraCaptureSession.StateCallback() &#123; @Override public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) &#123; // The camera is already closed if (null == mCameraDevice) &#123; return; &#125; // When the session is ready, we start displaying the preview. mCaptureSession = cameraCaptureSession; try &#123; // Auto focus should be continuous for camera preview. mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE); // Flash is automatically enabled when necessary. setAutoFlash(mPreviewRequestBuilder); // Finally, we start displaying the camera preview. mPreviewRequest = mPreviewRequestBuilder.build(); mCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback, mBackgroundHandler); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onConfigureFailed( @NonNull CameraCaptureSession cameraCaptureSession) &#123; showToast(\"Failed\"); &#125; &#125;, null ); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125; &#125; 项目中有注释，不做过多说明 拍照拍照的过程就是我们向已经打开好的相机获取静态预览帧的过程。 对焦12345678910111213private void lockFocus() &#123; try &#123; // This is how to tell the camera to lock focus. mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_START); // Tell #mCaptureCallback to wait for the lock. mState = STATE_WAITING_LOCK; mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, mBackgroundHandler); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125; &#125; 向CameraCaptureSession发送对焦请求，并且对对焦是否成功进行监听，在mCaptureCallback中对回调进行处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private CameraCaptureSession.CaptureCallback mCaptureCallback = new CameraCaptureSession.CaptureCallback() &#123; private void process(CaptureResult result) &#123; switch (mState) &#123; case STATE_PREVIEW: &#123; // We have nothing to do when the camera preview is working normally. break; &#125; //等待对焦 case STATE_WAITING_LOCK: &#123; Integer afState = result.get(CaptureResult.CONTROL_AF_STATE); if (afState == null) &#123; captureStillPicture(); &#125; else if (CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED == afState || CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED == afState) &#123; // CONTROL_AE_STATE can be null on some devices Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE); if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) &#123; mState = STATE_PICTURE_TAKEN; //对焦完成 captureStillPicture(); &#125; else &#123; runPrecaptureSequence(); &#125; &#125; break; &#125; case STATE_WAITING_PRECAPTURE: &#123; // CONTROL_AE_STATE can be null on some devices Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE); if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE || aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) &#123; mState = STATE_WAITING_NON_PRECAPTURE; &#125; break; &#125; case STATE_WAITING_NON_PRECAPTURE: &#123; // CONTROL_AE_STATE can be null on some devices Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE); if (aeState == null || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) &#123; mState = STATE_PICTURE_TAKEN; captureStillPicture(); &#125; break; &#125; &#125; &#125; 拍摄图片12345678910111213141516171819202122232425262728293031323334353637383940private void captureStillPicture() &#123; try &#123; final Activity activity = getActivity(); if (null == activity || null == mCameraDevice) &#123; return; &#125; // This is the CaptureRequest.Builder that we use to take a picture. final CaptureRequest.Builder captureBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE); captureBuilder.addTarget(mImageReader.getSurface()); // Use the same AE and AF modes as the preview. captureBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE); setAutoFlash(captureBuilder); // Orientation int rotation = activity.getWindowManager().getDefaultDisplay().getRotation(); captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation)); CameraCaptureSession.CaptureCallback CaptureCallback = new CameraCaptureSession.CaptureCallback() &#123; @Override public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) &#123; showToast(\"Saved: \" + mFile); Log.d(TAG, mFile.toString()); unlockFocus(); &#125; &#125;; mCaptureSession.stopRepeating(); mCaptureSession.abortCaptures(); mCaptureSession.capture(captureBuilder.build(), CaptureCallback, null); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125; &#125; 代码中有相应的注释。注意Demo中的onCaptureCompleted完成后，又调用unlockFocus()解锁了焦点。是因为Demo做的是连续拍照，如果实现的是只拍一张照片，需要将unlockFocus()去掉。 存图片存图片的操作是在之前设置ImageReader的监听方法里面进行存储的。 123456789private final ImageReader.OnImageAvailableListener mOnImageAvailableListener = new ImageReader.OnImageAvailableListener() &#123; @Override public void onImageAvailable(ImageReader reader) &#123; mBackgroundHandler.post(new ImageSaver(reader.acquireNextImage(), mFile)); &#125; &#125;; 参考资料Android Camera2 使用总结 Android Camera2 简介","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"}]},{"title":"使用ZXing实现扫描多个条形码页面","slug":"20190103UseZXingScanCodes","date":"2019-01-03T09:08:54.000Z","updated":"2019-01-04T01:13:47.574Z","comments":true,"path":"2019/01/03/20190103UseZXingScanCodes/","link":"","permalink":"http://pvphero.github.io/2019/01/03/20190103UseZXingScanCodes/","excerpt":"1.前言ZXing是google官方推出的跨平台的基于Java实现处理扫面二维码或者条形码的库。支持很多格式，一维条码支持UPC-A，UPC-E，EAN-8，Code 39，Code 93等格式，二维条码支持QR Code，Data Matrix，PDF 417，MaxiCode等格式。 我们通常使用ZXing扫描的时候都是一个一个的去扫，但是用户的实际操作环境却不尽然。比如说下图：","text":"1.前言ZXing是google官方推出的跨平台的基于Java实现处理扫面二维码或者条形码的库。支持很多格式，一维条码支持UPC-A，UPC-E，EAN-8，Code 39，Code 93等格式，二维条码支持QR Code，Data Matrix，PDF 417，MaxiCode等格式。 我们通常使用ZXing扫描的时候都是一个一个的去扫，但是用户的实际操作环境却不尽然。比如说下图： 2.解决方案ZXing中有一个类GenericMultipleBarcodeReader 看下这个类的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public final class GenericMultipleBarcodeReader implements MultipleBarcodeReader &#123; private static final int MIN_DIMENSION_TO_RECUR = 100; private static final int MAX_DEPTH = 4; private final Reader delegate; public GenericMultipleBarcodeReader(Reader delegate) &#123; this.delegate = delegate; &#125; @Override public Result[] decodeMultiple(BinaryBitmap image) throws NotFoundException &#123; return decodeMultiple(image, null); &#125; @Override public Result[] decodeMultiple(BinaryBitmap image, Map&lt;DecodeHintType,?&gt; hints) throws NotFoundException &#123; List&lt;Result&gt; results = new ArrayList&lt;&gt;(); doDecodeMultiple(image, hints, results, 0, 0, 0); if (results.isEmpty()) &#123; throw NotFoundException.getNotFoundInstance(); &#125; return results.toArray(new Result[results.size()]); &#125; private void doDecodeMultiple(BinaryBitmap image, Map&lt;DecodeHintType,?&gt; hints, List&lt;Result&gt; results, int xOffset, int yOffset, int currentDepth) &#123; if (currentDepth &gt; MAX_DEPTH) &#123; return; &#125; Result result; try &#123; result = delegate.decode(image, hints); &#125; catch (ReaderException ignored) &#123; return; &#125; boolean alreadyFound = false; for (Result existingResult : results) &#123; if (existingResult.getText().equals(result.getText())) &#123; alreadyFound = true; break; &#125; &#125; if (!alreadyFound) &#123; results.add(translateResultPoints(result, xOffset, yOffset)); &#125; ResultPoint[] resultPoints = result.getResultPoints(); if (resultPoints == null || resultPoints.length == 0) &#123; return; &#125; int width = image.getWidth(); int height = image.getHeight(); float minX = width; float minY = height; float maxX = 0.0f; float maxY = 0.0f; for (ResultPoint point : resultPoints) &#123; if (point == null) &#123; continue; &#125; float x = point.getX(); float y = point.getY(); if (x &lt; minX) &#123; minX = x; &#125; if (y &lt; minY) &#123; minY = y; &#125; if (x &gt; maxX) &#123; maxX = x; &#125; if (y &gt; maxY) &#123; maxY = y; &#125; &#125; // Decode left of barcode if (minX &gt; MIN_DIMENSION_TO_RECUR) &#123; doDecodeMultiple(image.crop(0, 0, (int) minX, height), hints, results, xOffset, yOffset, currentDepth + 1); &#125; // Decode above barcode if (minY &gt; MIN_DIMENSION_TO_RECUR) &#123; doDecodeMultiple(image.crop(0, 0, width, (int) minY), hints, results, xOffset, yOffset, currentDepth + 1); &#125; // Decode right of barcode if (maxX &lt; width - MIN_DIMENSION_TO_RECUR) &#123; doDecodeMultiple(image.crop((int) maxX, 0, width - (int) maxX, height), hints, results, xOffset + (int) maxX, yOffset, currentDepth + 1); &#125; // Decode below barcode if (maxY &lt; height - MIN_DIMENSION_TO_RECUR) &#123; doDecodeMultiple(image.crop(0, (int) maxY, width, height - (int) maxY), hints, results, xOffset, yOffset + (int) maxY, currentDepth + 1); &#125; &#125; private static Result translateResultPoints(Result result, int xOffset, int yOffset) &#123; ResultPoint[] oldResultPoints = result.getResultPoints(); if (oldResultPoints == null) &#123; return result; &#125; ResultPoint[] newResultPoints = new ResultPoint[oldResultPoints.length]; for (int i = 0; i &lt; oldResultPoints.length; i++) &#123; ResultPoint oldPoint = oldResultPoints[i]; if (oldPoint != null) &#123; newResultPoints[i] = new ResultPoint(oldPoint.getX() + xOffset, oldPoint.getY() + yOffset); &#125; &#125; Result newResult = new Result(result.getText(), result.getRawBytes(), result.getNumBits(), newResultPoints, result.getBarcodeFormat(), result.getTimestamp()); newResult.putAllMetadata(result.getResultMetadata()); return newResult; &#125;&#125; 可以看到GenericMultipleBarcodeReader中decodeMultiple返回 Result[],所以我们可以根据这个类实现条形码的多个返回。 3.实现过程3.1 gradle引入ZXing包12implementation('com.journeyapps:zxing-android-embedded:3.6.0') &#123; transitive = false &#125; implementation 'com.google.zxing:core:3.3.2' 3.2 调用ZXing的扫描页面1234567IntentIntegrator intentIntegrator = new IntentIntegrator(MainActivity.this); intentIntegrator .setPrompt(\"\") .setBeepEnabled(false) .setBarcodeImageEnabled(true) .setDesiredBarcodeFormats(IntentIntegrator.CODE_128) .initiateScan(); 这里将setBarcodeImageEnabled(true)设置成true，就可以在activity的回调里面获取到扫描的二维码的路径。 3.3 在onActivityResult中处理123456789101112131415161718192021222324252627282930313233@Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; IntentResult result = IntentIntegrator.parseActivityResult(requestCode, resultCode, data); LogUtils.i(TAG,result.toString()); Bitmap bMap = BitmapFactory.decodeFile(result.getBarcodeImagePath()); int[] data2 = new int[bMap.getWidth() * bMap.getHeight()]; bMap.getPixels(data2, 0, bMap.getWidth(), 0, 0, bMap.getWidth(), bMap.getHeight()); RGBLuminanceSource rgbLuminanceSource = new RGBLuminanceSource(bMap.getWidth(),bMap.getHeight(),data2); LuminanceSource source = rgbLuminanceSource; BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); Hashtable&lt;DecodeHintType, Object&gt; hints = new Hashtable&lt;DecodeHintType, Object&gt; (); hints.put(DecodeHintType.TRY_HARDER, Boolean.TRUE); MultiFormatReader mreader = new MultiFormatReader(); GenericMultipleBarcodeReader multireader = new GenericMultipleBarcodeReader(mreader); try &#123; Result[] result2 = multireader.decodeMultiple(bitmap,hints); if(result != null)&#123; for(Result kp : result2) &#123; System.out.println(kp.toString()); LogUtils.i(TAG,kp.toString()); &#125; &#125; &#125; catch (NotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 4.运行效果在log中我们可以看到扫描的结果 5.结论我们可以通过GenericMultipleBarcodeReader来实现扫面多个条形码，但是效果可能不是很稳定，这个识别的效果跟相机扫描出来的图片有关，先记下来，以后再好好优化下。","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"}]},{"title":"SuperEditText 用法说明","slug":"20181127SuperEditTextUsage","date":"2018-11-27T09:37:41.000Z","updated":"2019-01-04T01:05:48.545Z","comments":true,"path":"2018/11/27/20181127SuperEditTextUsage/","link":"","permalink":"http://pvphero.github.io/2018/11/27/20181127SuperEditTextUsage/","excerpt":"SuperEditText使用说明控件地址：https://github.com/pvphero/SuperEditText 1.控件的功能 EditText一键清除功能 TextInputEditText下方提示语可以显示隐藏 清除按钮可以显示隐藏 EditText 错误提示 Layout错误提示 失去焦点时，提示的文字消失；获得焦点时，提示的文字显示","text":"SuperEditText使用说明控件地址：https://github.com/pvphero/SuperEditText 1.控件的功能 EditText一键清除功能 TextInputEditText下方提示语可以显示隐藏 清除按钮可以显示隐藏 EditText 错误提示 Layout错误提示 失去焦点时，提示的文字消失；获得焦点时，提示的文字显示 2.控件用法说明 XML代码 1234567891011121314151617181920212223&lt;com.vv.superedittextlib.FloatingEditTextLayout android:id=\"@+id/edittext_layout_error\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"16dp\" android:hint=\"Layout显示错误\" android:imeOptions=\"actionDone\" android:inputType=\"textCapWords|textEmailAddress\" android:maxLength=\"100\" android:maxLines=\"2\" android:paddingRight=\"10dp\" android:textAllCaps=\"true\" android:textColor=\"?colorPrimary\" android:textSize=\"18sp\" android:textStyle=\"italic\" app:hintAnimationEnabled=\"true\" app:hintTextAppearance=\"@style/HintTextAppearance\" app:suet_clearButton=\"true\" app:suet_floatingLabelText=\"超过10个字，提示跟清楚按钮会消失，Layout显示错误\" app:suet_floatingLabelTextColor=\"?colorPrimary\" app:suet_isSafeInputText=\"true\"&gt; &lt;/com.vv.superedittextlib.FloatingEditTextLayout&gt; Java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainActivity extends AppCompatActivity &#123; private FloatingEditTextLayout editTextLayoutError, editTextLayoutCase; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editTextLayoutError = findViewById(R.id.edittext_layout_error); editTextLayoutCase = findViewById(R.id.edittext_layout_case); editTextLayoutError.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (s.length() &gt; 10) &#123; editTextLayoutError.setError(null); editTextLayoutError.hideFloatTextView(); ((ClearEditText) editTextLayoutError.getEditText()).setShowClearButton(false); editTextLayoutError.setLayoutError(null); &#125; else &#123; editTextLayoutError.setLayoutError(\"身份证号码错误!\"); editTextLayoutError.showFloatTextView(); ((ClearEditText) editTextLayoutError.getEditText()).setShowClearButton(true); &#125; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); editTextLayoutCase.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (s.length() &lt; 10) &#123; editTextLayoutCase.setError(\"位数错误\"); &#125; else &#123; editTextLayoutCase.setError(null); &#125; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125;&#125; 运行效果 3.控件说明3.1 控件组成FloatingEditTextLayout是一个组合控件，该控件继承自 TextInputLayout,内部集成了ClearEditText 和 TextView ClearEditText 是用来代替 TextInputEditText,并实现一键清除功能的EditText TextView 该控件是用来实现中间的提示字 3.2 控件公共方法说明 FloatingEditTextLayout.getText() 获取editText的Text FloatingEditTextLayout.setText() 设置editText的Text FloatingEditTextLayout.setError(@Nullable CharSequence errorText) 设置editText的error FloatingEditTextLayout.setLayoutError(@Nullable CharSequence errorText) 设置Layout的Error FloatingEditTextLayout.setHint(@StringRes int hintRes) 设置Hint FloatingEditTextLayout.addTextChangedListener(TextWatcher textWatcher) 监听editText的TextChange FloatingEditTextLayout.removeTextChangedListener(TextWatcher textWatcher) 移除editText textChange的监听事件 FloatingEditTextLayout.getEditText() 获取EditText FloatingEditTextLayout.isFloatingLabelAlwaysShown() 判断是否要一直显示提示的字 FloatingEditTextLayout.setFloatingLabelAlwaysShown() 设置提示的字是否一直显示 FloatingEditTextLayout.hideFloatTextView() 隐藏提示的字 FloatingEditTextLayout.showFloatTextView() 显示提示的字 FloatingEditTextLayout.getFloatLableText() 获取提示的字 FloatingEditTextLayout.setFloatLableText(String floatLableText) 设置提示的字 FloatingEditTextLayout.setEnabled(boolean enabled) 设置enable，如果enable=false则隐藏提示的字，如果enable=true则显示提示的字 ClearEditText.setOnFocusChangeListener() ClearEditText设置焦点的监听事件 ClearEditText.isShowClearButton() 判断是否显示ClearButton ClearEditText.setShowClearButton(boolean showClearButton) 设置ClearButton是否显示 ClearEditText.getIconSize() 获取Icon的大小 ClearEditText.setIconSize(int iconSize) 设置Inco的大小 LicenseCopyright 2018 pvphero Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"自定义控件","slug":"自定义控件","permalink":"http://pvphero.github.io/tags/自定义控件/"}]},{"title":"Android使用ToolBar+DrawerLayout+NavigationView实现侧滑抽屉效果","slug":"20180704AndroidUseDrawerLayout","date":"2018-07-04T05:18:18.000Z","updated":"2019-01-25T01:45:04.237Z","comments":true,"path":"2018/07/04/20180704AndroidUseDrawerLayout/","link":"","permalink":"http://pvphero.github.io/2018/07/04/20180704AndroidUseDrawerLayout/","excerpt":"学习目的 学会使用DrawerLayout 学会使用NavigationView 学会使用ToolBar+DrawerLayout+NavigationView实现侧滑抽屉效果 学会实现Toolbar在顶部以及Toolbar被遮挡的两种效果","text":"学习目的 学会使用DrawerLayout 学会使用NavigationView 学会使用ToolBar+DrawerLayout+NavigationView实现侧滑抽屉效果 学会实现Toolbar在顶部以及Toolbar被遮挡的两种效果 效果展示侧滑控件我们在开发的过程中经常用到,废话不多说,先上图: 实现过程如果要实现上图的展示效果,需要先创建个BaseActivit类,这个类里面包含Toolbar的初始化,然后再创建DrawerLayout相关的Activity 创建BaseActivity及相关XML文件 activity_base.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/colorPrimary\" app:contentInsetStartWithNavigation=\"0dp\" android:theme=\"@style/ToolBarStyle\" app:titleTextColor=\"@color/white\"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;FrameLayout android:id=\"@+id/frameLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; BaseActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.vv.drawerlayout.ui.base;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.LayoutInflater;import android.view.View;import android.widget.FrameLayout;import com.vv.drawerlayout.R;import butterknife.ButterKnife;/** * @author ShenZhenWei * @date 2018/7/4 */public abstract class BaseActivity extends AppCompatActivity &#123; protected Toolbar mToolbar; protected FrameLayout mContainerLayout; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_base); mToolbar = findViewById(R.id.toolbar); mContainerLayout = findViewById(R.id.frameLayout); boolean isToobar = initToolbar(); if (isToobar) &#123; setSupportActionBar(mToolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); mToolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onNavigationClick(); &#125; &#125;); &#125; else &#123; mToolbar.setVisibility(View.GONE); &#125; initContent(getLayoutId()); &#125; private void initContent(int layoutId) &#123; if (layoutId != 0) &#123; View contentView = LayoutInflater.from(this).inflate(layoutId, mContainerLayout, false); mContainerLayout.addView(contentView); ButterKnife.bind(this); initViews(); &#125; &#125; /** * 初始化布局 */ protected abstract void initViews(); /** * 获取布局控件 * * @return */ protected abstract int getLayoutId(); private void onNavigationClick() &#123; finish(); &#125; /** * 初始化Toolbar * * @return */ protected abstract boolean initToolbar();&#125; 创建DrawerLayout相关的Activity以及相关的XML文件 activity_main.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.MainActivity\"&gt; &lt;android.support.design.widget.NavigationView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/navigation_view\" android:layout_gravity=\"left|start\" app:headerLayout=\"@layout/header_layout\" app:menu=\"@menu/navigation_menu\"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; header_layout.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:gravity=\"center\" android:background=\"@color/_0091ea\" android:orientation=\"vertical\" &gt; &lt;ImageView android:id=\"@+id/img_avatar\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher_round\" /&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:textColor=\"@color/white\" android:text=\"\" /&gt;&lt;/LinearLayout&gt; navigation_menu.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;item android:id=\"@+id/menu_favorite_article\" android:icon=\"@drawable/ic_favorite_gray_24dp\" android:title=\"@string/favorite_article\" app:showAsAction=\"ifRoom\" /&gt; &lt;item android:id=\"@+id/menu_about\" android:icon=\"@drawable/ic_about_us_gray_24dp\" android:title=\"@string/about_us\" app:showAsAction=\"ifRoom\" /&gt; &lt;item android:id=\"@+id/menu_exit\" android:icon=\"@drawable/ic_exit_to_app_gray_24dp\" android:title=\"@string/exit\" app:showAsAction=\"ifRoom\" /&gt;&lt;/menu&gt; 如果使用Toolbar,那么需要把系统的主题换成没有ActionBar的主题,修改style.xml文件 12345678910111213141516&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme.Base\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name=\"AppTheme\" parent=\"AppTheme.Base\"&gt;&lt;/style&gt; &lt;style name=\"ToolBarStyle\" parent=\"@style/BaseToolBarStyle\"&gt;&lt;/style&gt;&lt;/resources&gt; MainActivity实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.vv.drawerlayout.ui;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.design.widget.NavigationView;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBarDrawerToggle;import android.view.MenuItem;import com.vv.drawerlayout.R;import com.vv.drawerlayout.ui.base.BaseActivity;import butterknife.Bind;/** * @author ShenZhenWei */public class MainActivity extends BaseActivity &#123; @Bind(R.id.navigation_view) NavigationView mNavigationView; @Bind(R.id.drawer_layout) DrawerLayout mDrawerLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActionBarDrawerToggle mToggle = new ActionBarDrawerToggle(this,mDrawerLayout,mToolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close); mToggle.syncState(); mDrawerLayout.addDrawerListener(mToggle); mNavigationView.setItemIconTintList(null); mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; return false; &#125; &#125;); &#125; @Override protected void initViews() &#123; &#125; @Override protected int getLayoutId() &#123; return R.layout.activity_main; &#125; @Override protected boolean initToolbar() &#123; mToolbar.setTitle(R.string.home); mToolbar.setNavigationIcon(R.drawable.ic_menu_black_24dp); return true; &#125;&#125; 运行查看效果 优化但是现在我们发现侧边栏是没有选中状态的,如效果图所示, 我们怎么才能是左边的导航栏有选择状态呢? 给左边的导航栏加上选中效果 首先在布局文件中,NavigationView的控件的meun中注明一个behavior 1234567&lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:title=\"@string/home\"&gt; &lt;/item&gt;&lt;/group&gt; 1android:checkableBehavior=\"single\" 表示每一项都是单选,如果不标明的话,NavigationView不会有选中效果. 在Java文件中增加监听器 1mNavigationView.setNavigationItemSelectedListener(onNavigationItemSelectedListener); 1234567891011121314151617181920NavigationView.OnNavigationItemSelectedListener onNavigationItemSelectedListener = new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.menu_favorite_article: break; case R.id.menu_about: break; case R.id.menu_exit: break; case R.id.menu_home: break; default: break; &#125; //关闭侧边栏 mDrawerLayout.closeDrawers(); return true; &#125; &#125;; 运行效果 改变图标的颜色我们给刚刚增加的NavigationView的控件的meun的Item增加一个icon 123456789&lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/menu_home\" android:icon=\"@mipmap/ic_launcher\" android:title=\"@string/home\"&gt; &lt;/item&gt;&lt;/group&gt; ok看下现在的效果: 5我们发现首页 旁边的图标变成了黑色.这并不是我们想要的. 我们怎么去更改Icon的颜色呢,有两种方法: 在NavigationView的布局xml文件里增加app:itemIconTint=&quot;@color/xxx&quot;属性,可以设置Icon的图片颜色为统一的一种颜色 activity_main.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.MainActivity\"&gt; &lt;android.support.design.widget.NavigationView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/navigation_view\" android:layout_gravity=\"left|start\" app:headerLayout=\"@layout/header_layout\" app:menu=\"@menu/navigation_menu\" app:itemIconTint=\"@color/_0091ea\"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 运行效果如下: 我们可以看到所有的Icon的图片颜色全部换成了统一的蓝色.但是首页旁边的Icon仍不是我们想要的图标颜色.这就得需要第二种方法了. 我们如果想让Icon显示本省的颜色,就得在java文件里面调用以下方法: 1mNavigationView.setItemIconTintList(null); MainActivity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.vv.drawerlayout.ui;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.design.widget.NavigationView;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBarDrawerToggle;import android.view.MenuItem;import com.vv.drawerlayout.R;import com.vv.drawerlayout.ui.base.BaseActivity;import butterknife.Bind;/** * @author ShenZhenWei */public class MainActivity extends BaseActivity &#123; @Bind(R.id.navigation_view) NavigationView mNavigationView; @Bind(R.id.drawer_layout) DrawerLayout mDrawerLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActionBarDrawerToggle mToggle = new ActionBarDrawerToggle(this,mDrawerLayout,mToolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close); mToggle.syncState(); mDrawerLayout.addDrawerListener(mToggle); mNavigationView.setItemIconTintList(null); mNavigationView.setNavigationItemSelectedListener(onNavigationItemSelectedListener); &#125; @Override protected void initViews() &#123; &#125; @Override protected int getLayoutId() &#123; return R.layout.activity_main; &#125; @Override protected boolean initToolbar() &#123; mToolbar.setTitle(R.string.home); mToolbar.setNavigationIcon(R.drawable.ic_menu_black_24dp); return true; &#125; NavigationView.OnNavigationItemSelectedListener onNavigationItemSelectedListener = new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.menu_favorite_article: break; case R.id.menu_about: break; case R.id.menu_exit: break; case R.id.menu_home: break; default: break; &#125; //关闭侧边栏 mDrawerLayout.closeDrawers(); return true; &#125; &#125;;&#125; 运行效果: 可以看到,这个效果就是我们想要的~ 改变Item的背景,改变Item的TextColor 如果要改变Item的背景,我们需要用到NavigationView的.app:itemBackground=&quot;&quot;方法 如果要改变Item的TextColor,我们需要用到NavigationView的app:itemTextColor=&quot;&quot;方法 activity_main.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.MainActivity\"&gt; &lt;android.support.design.widget.NavigationView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/navigation_view\" android:layout_gravity=\"left|start\" app:headerLayout=\"@layout/header_layout\" app:menu=\"@menu/navigation_menu\" app:itemBackground=\"@color/_0091ea\" app:itemTextColor=\"@color/white\" app:itemIconTint=\"@color/_0091ea\"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 效果如下: 给Item之间增加分割线我们只需要在以上基础上增加一个group_id即可.即:讲menu先放入到group组中,然后再给这个group赋上id的值,就能实现分割线效果. navigation_menu.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" &gt; &lt;item android:id=\"@+id/menu_favorite_article\" android:icon=\"@drawable/ic_favorite_gray_24dp\" android:title=\"@string/favorite_article\" app:showAsAction=\"ifRoom\" app:itemIconTint=\"@color/_0091ea\"/&gt; &lt;item android:id=\"@+id/menu_about\" android:icon=\"@drawable/ic_about_us_gray_24dp\" android:title=\"@string/about_us\" app:showAsAction=\"ifRoom\" /&gt; &lt;item android:id=\"@+id/menu_exit\" android:icon=\"@drawable/ic_exit_to_app_gray_24dp\" android:title=\"@string/exit\" app:showAsAction=\"ifRoom\" /&gt; &lt;group android:id=\"@+id/group_home\" android:checkableBehavior=\"single\" &gt; &lt;item android:id=\"@+id/menu_home\" android:icon=\"@mipmap/ic_launcher_round\" android:title=\"@string/home\"&gt; &lt;/item&gt; &lt;/group&gt;&lt;/menu&gt; 运行效果 怎么实现Toolbar被遮挡的侧滑抽屉效果我们常见的应用,像网易云音乐,QQ等都是Toolbar被遮挡的侧滑效果. 我们实现这种效果就得让DrawerLayout包含在Toolbar外面 activity_drawer_layout.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appBarLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"@string/home\" android:gravity=\"center\"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/navigation_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/header_layout\" app:itemIconTint=\"@color/colorAccent\" app:menu=\"@menu/navigation_menu\"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.vv.drawerlayout.ui;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.design.widget.NavigationView;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBarDrawerToggle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.MenuItem;import com.vv.drawerlayout.R;import butterknife.Bind;import butterknife.ButterKnife;/** * @author ShenZhenWei * @date 2018/7/5 */public class DrawerLayoutActivity extends AppCompatActivity &#123; @Bind(R.id.toolbar) Toolbar mToolbar; @Bind(R.id.navigation_view) NavigationView mNavigationView; @Bind(R.id.drawer_layout) DrawerLayout mDrawerLayout; private ActionBarDrawerToggle mToggle; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_drawer_layout); ButterKnife.bind(this); //设置Toolbar setToolbar(); //设置DrawerToggle 开关 setDrawerToggle(); //设置监听器 setListener(); &#125; private void setListener() &#123; mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); &#125; private void setDrawerToggle() &#123; mToggle=new ActionBarDrawerToggle(this,mDrawerLayout,mToolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close); mDrawerLayout.addDrawerListener(mToggle); //同步DrawerLayout的状态 mToggle.syncState(); &#125; private void setToolbar() &#123; setSupportActionBar(mToolbar); // 显示Home的图标 getSupportActionBar().setDisplayHomeAsUpEnabled(true); &#125;&#125; 注意:setSupportActionBar(mToolbar);一定要写在mDrawerLayout.addDrawerListener(mToggle);之前,否则将无法响应Home页面上的Icon点击事件. 运行效果: 代码为了方便,代码已经上传GitHub,敬请下载~","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"UI","slug":"UI","permalink":"http://pvphero.github.io/tags/UI/"}]},{"title":"AndroidStudio利用ADB WIFI调试程序","slug":"20180413UseWifiToDebugApp","date":"2018-04-13T10:41:18.000Z","updated":"2018-04-13T10:43:00.000Z","comments":true,"path":"2018/04/13/20180413UseWifiToDebugApp/","link":"","permalink":"http://pvphero.github.io/2018/04/13/20180413UseWifiToDebugApp/","excerpt":"前言手机的USB口被占用,想调试手机简直要崩溃.还好现在AndroidStudio支持WIFI调试,记录下WIFI调试程序的步骤.","text":"前言手机的USB口被占用,想调试手机简直要崩溃.还好现在AndroidStudio支持WIFI调试,记录下WIFI调试程序的步骤. 步骤 首先打开手机的USB调试选项,并通过USB连接手机 打开Terminal,输入adb tcpip 5555 如果没有出现错误则会出现restarting in TCP mode port: 5555则说明是正确的. 再输入adb connect &lt;手机的WLAN IP&gt;:5555 如果回显connected to &lt;手机的WLAN IP&gt;:5555 则说明连接成功. 断开USB连接 我们在Logcat中可以看到调试信息了 如果要切回USB模式,输入1$ adb usb 回显restarting in USB mode,说明切换成功.","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"Debug","slug":"Debug","permalink":"http://pvphero.github.io/tags/Debug/"}]},{"title":"StopWorld组织成立","slug":"20180403StopWorld","date":"2018-04-03T15:40:40.000Z","updated":"2018-04-03T15:59:54.000Z","comments":true,"path":"2018/04/03/20180403StopWorld/","link":"","permalink":"http://pvphero.github.io/2018/04/03/20180403StopWorld/","excerpt":"StopWorld组织在今天成立了,成立的缘由是翔哥提出来要维护一套面试的项目.为啥起这个名字呢?翔哥说JVM有个很牛逼的函数,这个函数就叫StopWorld,听起来很酷炫,有种逆天的感觉,哈哈~ 回到垃圾回收上，在开始学习GC之前你应该知道一个词：stop-the-world。不管选择哪种GC算法，stop-the-world都是不可避免的。Stop-the-world意味着从应用中停下来并进入到GC执行过程中去。一旦Stop-the-world发生，除了GC所需的线程外，其他线程都将停止工作，中断了的线程直到GC任务结束才继续它们的任务。GC调优通常就是为了改善stop-the-world的时间。 成立这个组织的最初目的是为了维护一套便于我们回顾一些知识的面试题,简单说下我们的项目成员:翔哥,浩哥,鑫鑫","text":"StopWorld组织在今天成立了,成立的缘由是翔哥提出来要维护一套面试的项目.为啥起这个名字呢?翔哥说JVM有个很牛逼的函数,这个函数就叫StopWorld,听起来很酷炫,有种逆天的感觉,哈哈~ 回到垃圾回收上，在开始学习GC之前你应该知道一个词：stop-the-world。不管选择哪种GC算法，stop-the-world都是不可避免的。Stop-the-world意味着从应用中停下来并进入到GC执行过程中去。一旦Stop-the-world发生，除了GC所需的线程外，其他线程都将停止工作，中断了的线程直到GC任务结束才继续它们的任务。GC调优通常就是为了改善stop-the-world的时间。 成立这个组织的最初目的是为了维护一套便于我们回顾一些知识的面试题,简单说下我们的项目成员:翔哥,浩哥,鑫鑫 目前我们的项目初具规模 先贴出部分的Android的内容,以后会持续更新 Android基础目录- 1.了解Fragment么,说说Fragmment的生命周期- 2.安卓的事件分发机制- 3.Android重要术语解释- 4.Android启动模式- 5.Android IPC:Binder原理 知识点1 了解Fragment么,说说Fragmment的生命周期展开查看答案一张图概括,详细请看博客链接Fragment生命周期 2 安卓的事件分发机制展开查看答案 - Android事件的基础知识： 所有的Touch事件都封装到MotionEvent里面 事件处理包括三种情况，分别为：传递—-dispatchTouchEvent()函数、拦截—- onInterceptTouchEvent()函数、消费—-onTouchEvent()函数和OnTouchListener 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL等 每个事件都是以ACTION_DOWN开始ACTION_UP结束 - Android事件传递流程： 1. 事件都是从Activity.dispatchTouchEvent()开始传递 2. 事件由父View传递给子View，ViewGroup可以通过onInterceptTouchEvent()方法对事件拦截， 停止其向子view传递 3. 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递 ,这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会 Activityon.TouchEvent()函数。 4. 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来，也就是说ACTION_DOWN必须 返回true，之后的事件才会传递进来OnTouchListener优先于onTouchEvent()对事件进行消费 - 三张效果图辅助理解 View不处理事件流程图（View没有消费事件) View处理事件 事件拦截 &gt; Android-三张图搞定Touch事件传递机制 3 Android重要术语解释展开查看详细 1.ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期 2.ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作 3.ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。 4.ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。 5.Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。 6.ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。 7.ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。 8.TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。 4 Android启动模式展开查看答案1. standard:默认标准模式，每启动一个都会创建一个实例2. singleTop：栈顶复用，如果在栈顶就调用onNewIntent复用，从onResume()开始3. singleTask：栈内复用，本栈内只要用该类型Activity就会调到栈顶复用，从onResume()开始4. singleInstance：单例模式，除了3中特性，系统会单独给该Activity创建一个栈 5 Android IPC Binder原理展开查看答案1. 在Activity和Service进行通讯的时候，用到了Binder。 1. 当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作 2. 当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。2. 系统给我们生成的Binder： 1. Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service 2. Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。3. 哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。4. 当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。5. 如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。6. IPC的方式有：Bundle（在Intent启动的时候传入，不过是一次性的），文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，AIDL，ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，Socket","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"Interview","slug":"Interview","permalink":"http://pvphero.github.io/tags/Interview/"}]},{"title":"由Dialog里面嵌套ListView之后的高度自适应引起的ListView性能优化","slug":"20180330AndroidListViewInDialog","date":"2018-03-30T05:15:37.000Z","updated":"2018-03-30T06:32:28.000Z","comments":true,"path":"2018/03/30/20180330AndroidListViewInDialog/","link":"","permalink":"http://pvphero.github.io/2018/03/30/20180330AndroidListViewInDialog/","excerpt":"先说ListView给高的正确做法.android:layout_height属性： 必须将ListView的布局高度属性设置为非“wrap_content”（可以是“match_parent / fill_parent / 400dp等绝对数值”）","text":"先说ListView给高的正确做法.android:layout_height属性： 必须将ListView的布局高度属性设置为非“wrap_content”（可以是“match_parent / fill_parent / 400dp等绝对数值”） 废话少说先来张bug图填楼 前言随着RecyclerView的普及,ListView差不多是安卓快要淘汰的控件了,但是我们有时候还是会用到,基本上可以说是前些年最常用的Android控件之一了.抛开我们的主题,我们先来谈谈ListView的一些小小的细节,可能是很多开发者在开发过程中并没有注意到的细节,这些细节设置会影响到我们的App的性能. android:layout_height属性 我们在使用ListView的时候很可能随手就会写一个layout_height=”wrap_content”或者layout_height=”match_parent”,非常非常普通,咋一看,我写的没错啊…可是实际上layout_height=”wrap_content” 是错误的写法!!!会严重影响程序的性能 我们先来做一个实验:xml布局文件如下1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/list_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; &gt;&lt;/ListView&gt;&lt;/LinearLayout&gt; java部分代码 运行log 我们会发现getView总共被调用了15次!其中4次是null的,11次为重复调用,ListView的item数目只有3项!!!太可怕了 我们试着将ListView的高度属性改为layout_height=”match_parent”,然后看看我们可以看到getView()只被调用了3次!这应该是我们期望的结果! 原因分析:了解原因前,我们应该先了解View的绘制流程,之前我的博客没有关于View绘制流程的介绍,那么在这边说一下,是一个很重要的知识点.View的绘制流程是通过 onMeasure()-&gt;onLayout()-&gt;onDraw() onMeasure() :主要工作是测量视图的大小.从顶层的父View到子View递归调用measure方法,measure方法又回调onMeasure(). onLayout: 主要工作是确定View的位置,进行页面布局.从顶层的父View向子View的递归调用view.layout方法的过程,即父View根据上一步measure子view所得到的布局大小和布局参数,将子view放在合适的位置上 onDraw() 主要工作是绘制视图.ViewRoot创建一个Canvas对象,然后调用onDraw()方法.总共6个步骤.1.绘制视图背景,2.保存当前画布的图层(Layer),3.绘制View内容,4.绘制View的子View视图,没有的话就不绘制,5.还原图层,6.绘制滚动条. 了解了View的绘制流程,那么我们回到这个问题上.设置ListView的属性layout_height=”wrap_content”,就意味着Listview的高度由子View决定,当在onMeasure()的时候,需要测量子View的高度,那我们来看看Listview的onMeasure()方法.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Sets up mListPadding super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childWidth = 0; int childHeight = 0; int childState = 0; mItemCount = mAdapter == null ? 0 : mAdapter.getCount(); if (mItemCount &gt; 0 &amp;&amp; (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) &#123; final View child = obtainView(0, mIsScrap); measureScrapChild(child, 0, widthMeasureSpec); childWidth = child.getMeasuredWidth(); childHeight = child.getMeasuredHeight(); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (recycleOnMeasure() &amp;&amp; mRecycler.shouldRecycleViewType( ((LayoutParams) child.getLayoutParams()).viewType)) &#123; mRecycler.addScrapView(child, 0); &#125; &#125; if (widthMode == MeasureSpec.UNSPECIFIED) &#123; widthSize = mListPadding.left + mListPadding.right + childWidth + getVerticalScrollbarWidth(); &#125; else &#123; widthSize |= (childState&amp;MEASURED_STATE_MASK); &#125; if (heightMode == MeasureSpec.UNSPECIFIED) &#123; heightSize = mListPadding.top + mListPadding.bottom + childHeight + getVerticalFadingEdgeLength() * 2; &#125; if (heightMode == MeasureSpec.AT_MOST) &#123; // TODO: after first layout we should maybe start at the first visible position, not 0 heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1); &#125; setMeasuredDimension(widthSize , heightSize); mWidthMeasureSpec = widthMeasureSpec; &#125; 其中1234if (heightMode == MeasureSpec.AT_MOST) &#123; // TODO: after first layout we should maybe start at the first visible position, not 0 heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1); &#125; 比较重要 再看measureHeightOfChildren()1234567891011121314151617181920212223242526272829final int measureHeightOfChildren(int widthMeasureSpec, int startPosition, int endPosition, final int maxHeight, int disallowPartialChildPosition) &#123; ... for (i = startPosition; i &lt;= endPosition; ++i) &#123; child = obtainView(i, isScrap); measureScrapChild(child, i, widthMeasureSpec); ... // Recycle the view before we possibly return from the method if (recyle &amp;&amp; recycleBin.shouldRecycleViewType( ((LayoutParams) child.getLayoutParams()).viewType)) &#123; recycleBin.addScrapView(child, -1); &#125; returnedHeight += child.getMeasuredHeight(); if (returnedHeight &gt;= maxHeight) &#123; ... &#125; if ((disallowPartialChildPosition &gt;= 0) &amp;&amp; (i &gt;= disallowPartialChildPosition)) &#123; ... &#125; &#125; return returnedHeight; &#125; obtainView(i, isScrap)是子View的实例measureScrapChild(child, i, widthMeasureSpec); 测量子ViewrecycleBin.addScrapView(child, -1);将子View加入缓存,可以用来复用if (returnedHeight &gt;= maxHeight) {return ...;}如果已经测量的子View的高度大于maxHeight的话就直接return出循环,这样的做法也很好理解,其实是ListView很聪明的一种做法,你可以想想比如说这个屏幕只能画10个Item高度,你有20个Item,那么画出10个就行了,剩下的十个就没必要画了~ 我们现在看下obtainView()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263View obtainView(int position, boolean[] isScrap) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;); isScrap[0] = false; // Check whether we have a transient state view. Attempt to re-bind the // data and discard the view if we fail. final View transientView = mRecycler.getTransientStateView(position); if (transientView != null) &#123; final LayoutParams params = (LayoutParams) transientView.getLayoutParams(); // If the view type hasn&apos;t changed, attempt to re-bind the data. if (params.viewType == mAdapter.getItemViewType(position)) &#123; final View updatedView = mAdapter.getView(position, transientView, this); // If we failed to re-bind the data, scrap the obtained view. if (updatedView != transientView) &#123; setItemViewLayoutParams(updatedView, position); mRecycler.addScrapView(updatedView, position); &#125; &#125; // Scrap view implies temporary detachment. isScrap[0] = true; return transientView; &#125; final View scrapView = mRecycler.getScrapView(position); final View child = mAdapter.getView(position, scrapView, this); if (scrapView != null) &#123; if (child != scrapView) &#123; // Failed to re-bind the data, return scrap to the heap. mRecycler.addScrapView(scrapView, position); &#125; else &#123; isScrap[0] = true; child.dispatchFinishTemporaryDetach(); &#125; &#125; if (mCacheColorHint != 0) &#123; child.setDrawingCacheBackgroundColor(mCacheColorHint); &#125; if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123; child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES); &#125; setItemViewLayoutParams(child, position); if (AccessibilityManager.getInstance(mContext).isEnabled()) &#123; if (mAccessibilityDelegate == null) &#123; mAccessibilityDelegate = new ListItemAccessibilityDelegate(); &#125; if (child.getAccessibilityDelegate() == null) &#123; child.setAccessibilityDelegate(mAccessibilityDelegate); &#125; &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); return child; &#125; 得到一个视图,它显示的数据与指定的位置。这叫做当我们已经发现的观点不是可供重用的回收站。剩下的唯一的选择是将一个古老的视图或制作一个新的.(这是方法注释的翻译,大致可以理解他的意思) 我们应该关注下以下两行代码:1234... final View scrapView = mRecycler.getScrapView(position); final View child = mAdapter.getView(position, scrapView, this);... 这两行代码的意思就是说先从缓存里面取出来一个废弃的view,然后将当前的位置跟view作为参数传入到getView()方法中.这个废弃的,然后又作为参数的view就是convertView. 然后我们总结下刚刚的步骤:A、测量第0项的时候，convertView肯定是null的 View scrapView = mRecycler.getScrapView(position)也是空的,所以我们在log上可以看到.B、第0项测量结束,这个第0项的View就被加入到复用缓存当中了；C、开始测量第1项，这时因为是有第0项的View缓存的，所以getView的参数convertView就是这个第0项的View缓存，然后重复B步骤添加到缓存，只不过这个View缓存还是第0项的View；D、继续测量第2项，重复C。 所以前面说到onMeasure方法会导致getView调用，而一个View的onMeasure方法调用时机并不是由自身决定，而是由其父视图来决定。ListView放在FrameLayout和RelativeLayout中其onMeasure方法的调用次数是完全不同的。在RelativeLayout中oMeasure()方法调用会翻倍. 由于onMeasure方法会多次被调用，上述问题中是两次，其实完整的调用顺序是onMeasure - onLayout - onMeasure - onLayout - onDraw。 所以根据上面的结论我们可以得出,如果LitsView的android:layout_height属性设置为wrap_content将会引起getView的多次测量 现象如上bug图… 产生的原因 ListView的高度设置成了android:layout_height属性设置为wrap_content ListView的父类是RelativeLayout,RelativiLayout布局会使子布局View的Measure周期翻倍,有兴趣可以看下三大基础布局性能比较 解决办法根据每个Item的高度,然后再根据Adapter的count来动态算高.代码如下:123456789101112131415161718192021222324252627282930313233public class SetHeight &#123; public void setListViewHeightBasedOnChildren(ListView listView, android.widget.BaseAdapter adapter) &#123; if (adapter==null)&#123; return; &#125; int totalHeight = 0; for (int i = 0; i &lt; adapter.getCount(); i++) &#123; // listAdapter.getCount()返回数据项的数目 View listItem = adapter.getView(i, null, listView); listItem.measure(0, 0); // 计算子项View 的宽高 totalHeight += listItem.getMeasuredHeight(); // 统计所有子项的总高度 &#125; ViewGroup.LayoutParams params = listView.getLayoutParams(); params.height = totalHeight + (listView.getDividerHeight() * (adapter.getCount() - 1)); // listView.getDividerHeight()获取子项间分隔符占用的高度 // params.height最后得到整个ListView完整显示需要的高度 listView.setLayoutParams(params); &#125;&#125; xml布局,注意要将ListView的父类设置为LinearLayout1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_above=&quot;@+id/txt_cancel&quot; android:orientation=&quot;vertical&quot;&gt; &lt;View android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;@dimen/y2&quot; android:background=&quot;#cccccc&quot; /&gt; &lt;ListView android:id=&quot;@+id/lv_remain_item&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;0dp&quot; android:cacheColorHint=&quot;#00000000&quot; &gt;&lt;/ListView&gt; &lt;View android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;@dimen/y2&quot; android:background=&quot;#cccccc&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;TextView android:id=&quot;@+id/txt_cancel&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;@dimen/y120&quot; android:layout_alignParentBottom=&quot;true&quot; android:gravity=&quot;center&quot; android:text=&quot;cancel&quot; android:textSize=&quot;@dimen/x32&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 然后在Listview使用处,调用该方法.12userListDialog.getmListView().setAdapter(scaleUserAdapter);SetHeight.setListViewHeightBasedOnChildren(userListDialog.getmListView(),scaleUserAdapter); 运行结果 getView()调用情况GitHub代码地址:ListViewDialog,喜欢的话欢迎Start","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"性能优化","slug":"性能优化","permalink":"http://pvphero.github.io/tags/性能优化/"},{"name":"ListView","slug":"ListView","permalink":"http://pvphero.github.io/tags/ListView/"}]},{"title":"Fragment生命周期","slug":"20180313AndroidInterViewFragment","date":"2018-03-13T05:47:49.000Z","updated":"2018-04-20T14:42:41.000Z","comments":true,"path":"2018/03/13/20180313AndroidInterViewFragment/","link":"","permalink":"http://pvphero.github.io/2018/03/13/20180313AndroidInterViewFragment/","excerpt":"整理一份安卓开发很基础的内容,但是很实用,帮助不了解Fragment在Activity里面生命周期的朋友.Fragment从Android v3.0版本开始引用,已经算的上是很老的组件了.我们都知道安卓有最基本的四大组件:Activity,Service,ContentProvider,broadcastReceiver.Fragment可以称为Android的第五大组件.肯定会有人问为什么第五大组件不是View?大家可以发现,说的四大组件都有自己的生命周期,而View没有自己的生命周期,所以大家不要把这个概念给混淆了.","text":"整理一份安卓开发很基础的内容,但是很实用,帮助不了解Fragment在Activity里面生命周期的朋友.Fragment从Android v3.0版本开始引用,已经算的上是很老的组件了.我们都知道安卓有最基本的四大组件:Activity,Service,ContentProvider,broadcastReceiver.Fragment可以称为Android的第五大组件.肯定会有人问为什么第五大组件不是View?大家可以发现,说的四大组件都有自己的生命周期,而View没有自己的生命周期,所以大家不要把这个概念给混淆了.接下来我们就来谈谈Fragment的生命周期.为了方便大家理解跟记忆,我用一张图来说明,Fragment在Activity里面的生命周期是什么样的.如下图:","categories":[{"name":"AndroidInterview","slug":"AndroidInterview","permalink":"http://pvphero.github.io/categories/AndroidInterview/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"fragment","slug":"fragment","permalink":"http://pvphero.github.io/tags/fragment/"}]},{"title":"AndroidStudio项目之CmakeLists解析","slug":"AS3NDKCMakeLists","date":"2018-02-09T07:23:23.000Z","updated":"2018-02-09T07:28:42.000Z","comments":true,"path":"2018/02/09/AS3NDKCMakeLists/","link":"","permalink":"http://pvphero.github.io/2018/02/09/AS3NDKCMakeLists/","excerpt":"前言我们在使用AndroidStudio 3.0开发NDK项目的时候CmakeLists.txt将是我们必须要用到的文件,如果你不懂怎么用CmakeLists配置NDK请先看之前的一篇博客:AndroidStudio 3.0 NDK环境搭建,如果已经了解CmakeLists配置NDK项目,ok,那我们接下来步入正题~","text":"前言我们在使用AndroidStudio 3.0开发NDK项目的时候CmakeLists.txt将是我们必须要用到的文件,如果你不懂怎么用CmakeLists配置NDK请先看之前的一篇博客:AndroidStudio 3.0 NDK环境搭建,如果已经了解CmakeLists配置NDK项目,ok,那我们接下来步入正题~ CmakeLists源码CMakeLists.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) 源码很简单除了注释的代码外,核心的代码也就那么几句. cmake_minimum_required(VERSION 3.4.1) Sets the minimum version of CMake required to build the native library. 用来设置编译本地native library的时候需要的Cmake最小版本.这个是创建AndroidStudio项目的时候自动生成,不需要太在意. add_library() 12345678add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp ) native-lib : 设置本地lib的nameSHARED : 表示编译生成的是动态链接库src/main/cpp/native-lib.cpp : 表示编译文件的相对路径,这里可以是一个文件的路径也可以是多个文件的路径 find_library() 这个的作用是用来让我们加一些编译本地NDK库的时候所用的到一些依赖库.log-lib 是这个库的别名,方便我们以后引用log 是我们调试的时候打印log的一个库 target_link_libraries()这个的目的是用来关联我们本地的库跟第三方的库.这里就是把native-lib库和log库关联起来. 自定义NDK的配置单个C/C++文件这个在之前的博客里有提到,可以翻看AndroidStudio 3.0 NDK环境搭建 多个C/C++文件我们在实际项目中,C++文件可能不止一个,如果有多个C++文件,我们的CmakeLists应该怎么配置呢?其实前面说add_library() 的时候提到了,路径可以是多个文件的路径.所以我们可以这么配置:12345678910add_library( # Sets the name of the library. hello # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/Hello.cpp src/main/cpp/Hi.cpp ) 只需要在路径处增加一个路径,就配置好了.可能只说这个,大家会有点迷茫,可以放在项目中来看下,我们基于上一篇文章的项目,实现这个多个NDK文件的配置过程.先回忆一下创建NDK项目的步骤: 创建一个Java文件 在这个类里面写一个native方法 生成头文件(*.h) 创建c文件并实现头文件里面的方法 Java文件里面加入静态方法块 配置grade 在Activity里面调用Jni 配置CmakeLists.txt文件 我们先创建一个Hi.java文件,并在Hi.java文件中写一个native方法,如下:生成Hi的头文件1$ cd app/src/main/java 1$ javah -d ../cpp com.vv.ndk.Hi 创建一个Hi.cpp c文件实现com_vv_ndk_Hi.h 头文件里面未实现的方法 1234#include \"com_vv_ndk_Hi.h\"JNIEXPORT jstring JNICALL Java_com_vv_ndk_Hi_sayHi(JNIEnv *env, jclass jclass1)&#123; return env-&gt;NewStringUTF(\"sat Hi\");&#125; Hi.java文件中加入静态代码块 注意这个System.loadLibrary 加载的是你本地库的名字 配置CmakeLists.txt文件12345678910111213141516cmake_minimum_required(VERSION 3.4.1)add_library( hello SHARED src/main/cpp/Hello.cpp src/main/cpp/Hi.cpp )find_library( log-lib log )target_link_libraries( hello $&#123;log-lib&#125; ) activity里面调用xml文件1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.vv.ndk.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/sample_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/textview&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; activity文件123456789101112131415public class MainActivity extends AppCompatActivity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = (TextView) findViewById(R.id.sample_text); tv.setText(Hello.sayHello()); textView=findViewById(R.id.textview); textView.setText(Hi.sayHi()); &#125;&#125; 运行效果 可以看到调用Hi文件的sayHi() 方法已经被调用了. 编译多个SO库编译多个so库的cpp目录结构 one 文件夹内的CmakeLists.txt 配置如下: 123add_library(one SHARED one.cpp)target_link_libraries(one $&#123;log-lib&#125; ) two 文件夹内CmakeLists.txt 配置如下: 123add_library(two SHARED two.cpp)target_link_libraries(two $&#123;log-lib&#125; ) app 项目的CmakeLists.txt 配置如下: 12345678910111213cmake_minimum_required(VERSION 3.4.1)add_library(hello SHARED src/main/cpp/Hello.cpp src/main/cpp/Hi.cpp)find_library(log-lib log )target_link_libraries(hello $&#123;log-lib&#125; )ADD_SUBDIRECTORY(src/main/cpp/one)ADD_SUBDIRECTORY(src/main/cpp/two) CmakeLists.txt文件支持继承,所以我们只需要在子配置文件中写不同的配置项就可以完成相应的配置.最后需要在项目的CmakeLists.txt文件中增加子配置文件的路径. 然后我们用Make构建Module app生成字节码文件这样就可以在/app/build/intermediates/cmake/debug/obj/arm64-v8a/ 路径下看到我们刚刚生成的so文件. 需要源码的同学可以直接从github上下载:NDKLearnDemo","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"http://pvphero.github.io/tags/NDK/"}]},{"title":"AndroidStudio 3.0 NDK环境搭建","slug":"AS3NDKEnvironment","date":"2018-02-08T10:59:33.000Z","updated":"2018-07-11T07:59:28.389Z","comments":true,"path":"2018/02/08/AS3NDKEnvironment/","link":"","permalink":"http://pvphero.github.io/2018/02/08/AS3NDKEnvironment/","excerpt":"前言网上关于NDK开发环境配置的相关博客已经很多,但是很少有关于NDK在AdnroidStduio 3.0以上的环境搭建相关的博客.所以特此记录下.首先是对NDK的介绍,先对NDK有个初步的印象:NDK(Native Development kit)是一个工作集,为了能让开发者可以更加直接的接触Android硬件资源和方便地使用传统的C/C++语言编写代码，NDK应运而生。在NDK公布以前，Android平台的第三方应用程序的编写只能依靠基于Java的Dalvik虚拟机进行开发。有了NDK后，开发者就可以更加方便的用传统的C/C++语言编写程序，并在程序封装文件（.apk）中直接嵌入","text":"前言网上关于NDK开发环境配置的相关博客已经很多,但是很少有关于NDK在AdnroidStduio 3.0以上的环境搭建相关的博客.所以特此记录下.首先是对NDK的介绍,先对NDK有个初步的印象:NDK(Native Development kit)是一个工作集,为了能让开发者可以更加直接的接触Android硬件资源和方便地使用传统的C/C++语言编写代码，NDK应运而生。在NDK公布以前，Android平台的第三方应用程序的编写只能依靠基于Java的Dalvik虚拟机进行开发。有了NDK后，开发者就可以更加方便的用传统的C/C++语言编写程序，并在程序封装文件（.apk）中直接嵌入 NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。 NDK集成了交叉编译器，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。 NDK可以自动地将so和Java应用一起打包，极大地减轻了开发人员的打包工作。 下载工具 NDK: NDK Downloads CMake:一个外部构建工具(AndroidStudio 3.0以上自带) LLDB:用于调试本地代码 这些工具都可以使用SDM Manager下载 当前博客所用的列子的环境如下 名称 版本号 AndroidStudio 3.0 JDK jdk1.8.0_101 NDk 16.1.4479499 compileSdkVersion 26 buildToolsVersion 26.1.0 minSdkVersion 21 targetSdkVersion 26 创建一个NDK项目new一个项目,并勾选include c++ support AndroidStudio 3.0上创建NDK项目的时候,记得勾选include c++ support,这样会很方便.接着一路next 最后点击finish. 这样一个NDK项目就已经创建好了,目录结构以及代码如下 可以看出来AS3.0勾选了include c++ support会比正常的项目多出来cpp文件夹跟CmakeLists.txt文件.这些将是我们在AS3.0上学习NDK环境开发的重点 这样一个NDK的项目就完全建好了,并且可以运行,我们来看下运行的效果 哈哈,是不是很方便?如果之前没有勾选include c++ support 就会很麻烦,这个可以在以后的博客里说下旧的NDK项目怎么在3.0上运行,3.0已经不同于2.0,现在先享受下AS给我们带来的方便吧~ 我们的项目里面Jni文件肯定不止一个,如果需要新的Jni文件的话,请按下面的步骤来 NDK自定义配置过程创建一个Java文件 在这个类里面写一个native方法 生成头文件(*.h)打开Terminal,给刚刚创建的类创建头文件.先cd到app/src/main/java目录下1cd app/src/main/java 然后使用javah命令 1javah -d ../cpp com.vv.ndk.Hello javah 执行java命令生成头文件(*.h)-d 在当前目录下创建一个文件夹,文件夹名字是cppcom.vv.ndk.Hello 包名.类名指定要生成那个java类文件的头文件所以这个命令的目的是在cpp的上一层目录下创建一个cpp文件夹,并对com.vv.ndk.Hello 生成一个头文件,如下图所示: 这个命令输入完以后在app/src/main/cpp/文件夹下多了一个com_vv_ndk_Hello.h文件,并且这个文件里面有一个未实现的方法Java_com_vv_ndk_Hello_sayHello,这个方法就是Hello.java方法里面对应的sayHello()方法 创建c文件并实现头文件里面的方法Java_com_vv_ndk_Hello_sayHello 这个文件是一个抽象的方法,我们需要创建一个*.c文件去实现这个方法. 我们在cpp文件夹下创建一个C++ Source File,命名为Hello.cpp 引入com_vv_ndk_Hello.h 头文件,并实现头文件里面的Java_com_vv_ndk_Hello_sayHello 方法 返回一个我们想要得到的值,代码如下 1234#include \"com_vv_ndk_Hello.h\"JNIEXPORT jstring JNICALL Java_com_vv_ndk_Hello_sayHello(JNIEnv *env, jclass jclass1)&#123; return env-&gt;NewStringUTF(\"say Hello\");&#125; Java文件里面加入静态方法块 System.loadLibrary(&quot;hello&quot;) 是NDK的moduleName 配置grade在app.gradle 文件的defaultConfig里面加上 ndk 的moduleName123456defaultConfig &#123; ... ndk&#123; moduleName &quot;hello&quot; &#125; &#125; 在Activity里面调用Jni1234567891011public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = (TextView) findViewById(R.id.sample_text); tv.setText(Hello.sayHello()); &#125;&#125; 运行以后发现崩溃,不要慌 崩溃是因为你还没有配置最关键的CmakeLists.txt文件 配置CmakeLists.txt文件12345678910add_library( # Sets the name of the library. hello # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/jni/Hello.cpp src/main/jni/Hi.cpp ) 1target_link_libraries( hello $&#123;log-lib&#125; ) ok,运行效果如下 这样调用Hello.sayHello()方法就显示出来了. 总结以上是创建NDK项目的过程,现在我们来总结下创建的整个步骤. 创建一个Java文件 在这个类里面写一个native方法 生成头文件(*.h) 创建c文件并实现头文件里面的方法 Java文件里面加入静态方法块 配置grade 在Activity里面调用Jni 配置CmakeLists.txt文件 博客就到这里吧,下面将会讲下CMakeLists的解析,看看这个文件到底是个啥.","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"http://pvphero.github.io/tags/NDK/"}]},{"title":"随笔","slug":"GoodGoodStudyDayDayUp","date":"2018-01-25T01:33:15.000Z","updated":"2018-01-25T01:36:54.000Z","comments":true,"path":"2018/01/25/GoodGoodStudyDayDayUp/","link":"","permalink":"http://pvphero.github.io/2018/01/25/GoodGoodStudyDayDayUp/","excerpt":"向上的路从不拥挤，是你选择了安逸","text":"向上的路从不拥挤，是你选择了安逸","categories":[],"tags":[]},{"title":"Anroid Intent跳转系统设置页面","slug":"AndroidIntentJumpToSysSettings","date":"2018-01-18T09:20:01.000Z","updated":"2018-01-18T09:44:40.000Z","comments":true,"path":"2018/01/18/AndroidIntentJumpToSysSettings/","link":"","permalink":"http://pvphero.github.io/2018/01/18/AndroidIntentJumpToSysSettings/","excerpt":"我们的app支持18种语言,为了测试能很快的跳转到语言的切换页面.所以专门扒拉了一下intent跳转系统所有设置页面的方法,记录下来,以后忘记了可以直接查看.","text":"我们的app支持18种语言,为了测试能很快的跳转到语言的切换页面.所以专门扒拉了一下intent跳转系统所有设置页面的方法,记录下来,以后忘记了可以直接查看.就是这么漂,就是这么酷炫~ android.provider.Settings1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891. ACTION_ACCESSIBILITY_SETTINGS ： // 跳转系统的辅助功能界面 Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS); startActivity(intent);2. ACTION_ADD_ACCOUNT ： // 显示添加帐户创建一个新的帐户屏幕。【测试跳转到微信登录界面】 Intent intent = new Intent(Settings.ACTION_ADD_ACCOUNT); startActivity(intent);3. ACTION_AIRPLANE_MODE_SETTINGS： // 飞行模式，无线网和网络设置界面 Intent intent = new Intent(Settings.ACTION_AIRPLANE_MODE_SETTINGS); startActivity(intent); 或者： ACTION_WIRELESS_SETTINGS ： Intent intent = new Intent(Settings.ACTION_WIFI_SETTINGS); startActivity(intent);4. ACTION_APN_SETTINGS： // 跳转 APN设置界面 Intent intent = new Intent(Settings.ACTION_APN_SETTINGS); startActivity(intent);5. 【需要参数】 ACTION_APPLICATION_DETAILS_SETTINGS： // 根据包名跳转到系统自带的应用程序信息界面 Uri packageURI = Uri.parse(\"package:\" + \"com.tencent.WBlog\"); Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS,packageURI); startActivity(intent);6. ACTION_APPLICATION_DEVELOPMENT_SETTINGS : // 跳转开发人员选项界面 Intent intent = new Intent(Settings.ACTION_APPLICATION_DEVELOPMENT_SETTINGS); startActivity(intent);7. ACTION_APPLICATION_SETTINGS ： // 跳转应用程序列表界面 Intent intent = new Intent(Settings.ACTION_APPLICATION_SETTINGS); startActivity(intent); 或者： ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS // 跳转到应用程序界面【所有的】 Intent intent = new Intent(Settings.ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS); startActivity(intent); 或者： ACTION_MANAGE_APPLICATIONS_SETTINGS ：// 跳转 应用程序列表界面【已安装的】 Intent intent = new Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS); startActivity(intent);8. ACTION_BLUETOOTH_SETTINGS ： // 跳转系统的蓝牙设置界面 Intent intent = new Intent(Settings.ACTION_BLUETOOTH_SETTINGS); startActivity(intent);9. ACTION_DATA_ROAMING_SETTINGS ： // 跳转到移动网络设置界面 Intent intent = new Intent(Settings.ACTION_DATA_ROAMING_SETTINGS); startActivity(intent);10. ACTION_DATE_SETTINGS ： // 跳转日期时间设置界面 Intent intent = new Intent(Settings.ACTION_DATA_ROAMING_SETTINGS); startActivity(intent);11. ACTION_DEVICE_INFO_SETTINGS ： // 跳转手机状态界面 Intent intent = new Intent(Settings.ACTION_DEVICE_INFO_SETTINGS); startActivity(intent);12. ACTION_DISPLAY_SETTINGS ： // 跳转手机显示界面 Intent intent = new Intent(Settings.ACTION_DISPLAY_SETTINGS); startActivity(intent);13. ACTION_DREAM_SETTINGS 【API 18及以上 没测试】 Intent intent = new Intent(Settings.ACTION_DREAM_SETTINGS); startActivity(intent);14. ACTION_INPUT_METHOD_SETTINGS ： // 跳转语言和输入设备 Intent intent = new Intent(Settings.ACTION_INPUT_METHOD_SETTINGS); startActivity(intent);15. ACTION_INPUT_METHOD_SUBTYPE_SETTINGS 【API 11及以上】 // 跳转 语言选择界面 【多国语言选择】 Intent intent = new Intent(Settings.ACTION_INPUT_METHOD_SUBTYPE_SETTINGS); startActivity(intent);16. ACTION_INTERNAL_STORAGE_SETTINGS // 跳转存储设置界面【内部存储】 Intent intent = new Intent(Settings.ACTION_INTERNAL_STORAGE_SETTINGS); startActivity(intent); 或者： ACTION_MEMORY_CARD_SETTINGS ： // 跳转 存储设置 【记忆卡存储】 Intent intent = new Intent(Settings.ACTION_MEMORY_CARD_SETTINGS); startActivity(intent);17. ACTION_LOCALE_SETTINGS ： // 跳转语言选择界面【仅有English 和 中文两种选择】 Intent intent = new Intent(Settings.ACTION_LOCALE_SETTINGS); startActivity(intent);18. ACTION_LOCATION_SOURCE_SETTINGS : // 跳转位置服务界面【管理已安装的应用程序。】 Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS); startActivity(intent);19. ACTION_NETWORK_OPERATOR_SETTINGS ： // 跳转到 显示设置选择网络运营商。 Intent intent = new Intent(Settings.ACTION_NETWORK_OPERATOR_SETTINGS); startActivity(intent);20. ACTION_NFCSHARING_SETTINGS ： // 显示NFC共享设置。 【API 14及以上】 Intent intent = new Intent(Settings.ACTION_NFCSHARING_SETTINGS); startActivity(intent);21. ACTION_NFC_SETTINGS ： // 显示NFC设置。这显示了用户界面,允许NFC打开或关闭。 【API 16及以上】 Intent intent = new Intent(Settings.ACTION_NFC_SETTINGS); startActivity(intent);22. ACTION_PRIVACY_SETTINGS ： // 跳转到备份和重置界面 Intent intent = new Intent(Settings.ACTION_PRIVACY_SETTINGS); startActivity(intent);23. ACTION_QUICK_LAUNCH_SETTINGS ： // 跳转快速启动设置界面 Intent intent = new Intent(Settings.ACTION_QUICK_LAUNCH_SETTINGS); startActivity(intent);24. ACTION_SEARCH_SETTINGS ： // 跳转到 搜索设置界面 Intent intent = new Intent(Settings.ACTION_SEARCH_SETTINGS); startActivity(intent);25. ACTION_SECURITY_SETTINGS ： // 跳转到安全设置界面 Intent intent = new Intent(Settings.ACTION_SECURITY_SETTINGS); startActivity(intent);26. ACTION_SETTINGS ： // 跳转到设置界面 Intent intent = new Intent(Settings.ACTION_SETTINGS); startActivity(intent);27. ACTION_SOUND_SETTINGS // 跳转到声音设置界面 Intent intent = new Intent(Settings.ACTION_SOUND_SETTINGS); startActivity(intent);28. ACTION_SYNC_SETTINGS ： // 跳转账户同步界面 Intent intent = new Intent(Settings.ACTION_SYNC_SETTINGS); startActivity(intent);29. ACTION_USER_DICTIONARY_SETTINGS ： // 跳转用户字典界面 Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_SETTINGS); startActivity(intent);30. ACTION_WIFI_IP_SETTINGS ： // 跳转到IP设定界面 Intent intent = new Intent(Settings.ACTION_WIFI_IP_SETTINGS); startActivity(intent);31. ACTION_WIFI_SETTINGS ： // 跳转Wifi列表设置 Intent intent = new Intent(Settings.ACTION_WIFI_SETTINGS); startActivity(intent); 跳转方式12Intent intent = new Intent(Settings.*********);startActivity(intent); 举个例子方法都贴完了怎么能不举个栗子,撸码爽爽 MainActivity.java123456789101112131415161718192021import android.content.Intent;import android.provider.Settings;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Settings.ACTION_LOCALE_SETTINGS); startActivity(intent); &#125; &#125;); &#125;&#125; activity_main123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"语言选择\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 实现效果","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"}]},{"title":"Service Intent must be explicit的解决方案","slug":"ServiceIntetMustBeExplicit","date":"2017-09-14T07:11:43.000Z","updated":"2018-07-11T08:04:52.257Z","comments":true,"path":"2017/09/14/ServiceIntetMustBeExplicit/","link":"","permalink":"http://pvphero.github.io/2017/09/14/ServiceIntetMustBeExplicit/","excerpt":"今天在学习AIDL的时候,通过以下步骤:","text":"今天在学习AIDL的时候,通过以下步骤: 在AndroidMenifest中声明service 12345678910&lt;service android:name=\".MyService\" android:process=\":remote\" android:exported=\"true\"&gt; &lt;intent-filter &gt; &lt;category android:name=\"android.intent.category.DEFAULT\"&gt;&lt;/category&gt; &lt;action android:name=\"com.ihealth.learnaidl.MyService\"&gt;&lt;/action&gt; &lt;/intent-filter&gt; &lt;/service&gt; 在客户端中绑定service 12345Intent intentService=new Intent(); intentService.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intentService.setAction(ACTION_BIND_SERVICE); MainActivity.this.bindService(intentService,mServiceConnection,BIND_AUTO_CREATE); 运行程序,结果报错了!java.lang.IllegalArgumentException: Service Intent must be explicit 经过查找资料Stackoverflow.com,发现是需要将隐含意图转换为显示的意图，然后启动再服务。 所以综合Stackoverflow上给出的解决方案,现在大体上有两种解决的方法. 1.先说一个简单的办法123456Intent mIntent = new Intent();//自定义的Service的actionmIntent.setAction(\"XXX.XXX.XXX\");//自定义Service的包名mIntent.setPackage(getPackageName());context.startService(mIntent); 即只需要多加一句话mIntent.setPackage(getPackageName());就可以解决. 2.另外一个比较麻烦的方法先通过一个函数将隐式调用转变为显示调用 123456789101112131415161718192021222324252627282930313233343536/*** * Android L (lollipop, API 21) introduced a new problem when trying to invoke implicit intent, * \"java.lang.IllegalArgumentException: Service Intent must be explicit\" * * If you are using an implicit intent, and know only 1 target would answer this intent, * This method will help you turn the implicit intent into the explicit form. * * Inspired from SO answer: http://stackoverflow.com/a/26318757/1446466 * @param context * @param implicitIntent - The original implicit intent * @return Explicit Intent created from the implicit original intent */ public static Intent createExplicitFromImplicitIntent(Context context, Intent implicitIntent) &#123; // Retrieve all services that can match the given intent PackageManager pm = context.getPackageManager(); List&lt;ResolveInfo&gt; resolveInfo = pm.queryIntentServices(implicitIntent, 0); // Make sure only one match was found if (resolveInfo == null || resolveInfo.size() != 1) &#123; return null; &#125; // Get component info and create ComponentName ResolveInfo serviceInfo = resolveInfo.get(0); String packageName = serviceInfo.serviceInfo.packageName; String className = serviceInfo.serviceInfo.name; ComponentName component = new ComponentName(packageName, className); // Create a new intent. Use the old one for extras and such reuse Intent explicitIntent = new Intent(implicitIntent); // Set the component to be explicit explicitIntent.setComponent(component); return explicitIntent; &#125; 然后调用 1234Intent intent = new Intent(); intent.setAction(ACTION_BIND_SERVICE); final Intent eintent = new Intent(createExplicitFromImplicitIntent(this,intent)); bindService(eintent,mServiceConnection, Service.BIND_AUTO_CREATE); 两种办法都可以解决.记下来,免得以后忘了.感谢Stackoverflow~Google In-App billing, IllegalArgumentException: Service Intent must be explicit, after upgrading to Android L Dev Preview Service Intent must be explicit: Intent","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"}]},{"title":"关于Android 7.0系统通知声音不能播放","slug":"AndroidNotificationSound","date":"2017-07-31T07:18:56.000Z","updated":"2017-07-31T07:28:28.000Z","comments":true,"path":"2017/07/31/AndroidNotificationSound/","link":"","permalink":"http://pvphero.github.io/2017/07/31/AndroidNotificationSound/","excerpt":"由于沉迷于撸(nong)码(yao),很久没有更新过博客了,甚是惭愧.公司的项目比较高大上,主要面对老外开发,所以要适配各种版本的Android机,项目里有个闹钟提醒患者吃药的功能,但是这个功能获取系统通知铃声在Android 6.0以下好好的,换了个7.0的手机却不能播放出声音了.Android的锅,我们不背,我们不背…但是能解决的还是解决下吧.","text":"由于沉迷于撸(nong)码(yao),很久没有更新过博客了,甚是惭愧.公司的项目比较高大上,主要面对老外开发,所以要适配各种版本的Android机,项目里有个闹钟提醒患者吃药的功能,但是这个功能获取系统通知铃声在Android 6.0以下好好的,换了个7.0的手机却不能播放出声音了.Android的锅,我们不背,我们不背…但是能解决的还是解决下吧. 问题现象及问题定位NotificationCompat.Builder.setSound(URI)的时候,发现没有发出任何声音,但是却显示出了一个错误. 问题分析 将系统铃声设置为系统通知铃声需要两个操作 通过RingtoneManager.ACTION_RINGTONE_PICKER,获取”/system/media/audio/notifications”路径下的音乐的URI 调用RingtoneManager.setActualDefaultRingtoneUri()，传入相应的uri和需要设置的铃声类型即可。 如果你使用的是file: Uri,在targetSdkVersion&gt;=24(Android 7.0以上)的时候是不适用的.因为Android 7.0的Uri会检查播放的声音是否是file:Uri禁用值 问题的解决方法只需要在调用声音的前面加一句黑代码 就可以完美解决 12grantUriPermission(\"com.android.systemui\", soundUri, Intent.FLAG_GRANT_READ_URI_PERMISSION); 这里的soundUri就是你调取系统声音的Uri 贴码说那么多没用的,不如撸一把代码.为了方便大家直接使用做了一个简单的demo,方便大家参考. 也可以从github上直接下载下来,RingStom 布局activity_main.xml文件 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/buttonRingtone\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"设置来电铃声\" /&gt; &lt;Button android:id=\"@+id/buttonAlarm\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"设置闹钟铃声\" /&gt; &lt;Button android:id=\"@+id/buttonNotification\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"设置通知铃声\" /&gt;&lt;/LinearLayout&gt; 相关的java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154public class MainActivity extends AppCompatActivity &#123; /* 3个按钮 */ private Button mButtonRingtone; private Button mButtonAlarm; private Button mButtonNotification; /* 自定义的类型 */ public static final int CODE_RINGSTONE = 0; public static final int CODE_ALARM = 1; public static final int CODE_NOTIFICATION = 2; /** * 来电铃声文件夹 * /system/media/audio/ringtones 系统来电铃声 * /sdcard/music/ringtones 用户来电铃声 */ private String strRingtoneFolder = \"/system/media/audio/ringtones\";// private String strRingtoneFolder = \"/sdcard/music/ringtones\"; /** * 闹钟铃声文件夹 * /system/media/audio/alarms 系统闹钟铃声 * /sdcard/music/alarms 用户闹钟铃声 */ private String strAlarmFolder = \"/system/media/audio/alarms\";// private String strAlarmFolder = \"/sdcard/music/alarms \"; /** * 闹钟铃声文件夹 * /system/media/audio/notifications 系统通知铃声 * /sdcard/music/notifications 用户通知铃声 */ private String strNotificationFolder = \"/system/media/audio/notifications\";// private String strNotificationFolder = \"/sdcard/music/notifications\"; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButtonRingtone = (Button) findViewById(R.id.buttonRingtone); mButtonAlarm = (Button) findViewById(R.id.buttonAlarm); mButtonNotification = (Button) findViewById(R.id.buttonNotification); mButtonRingtone.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; if (hasFolder(strRingtoneFolder)) &#123; // 打开系统铃声设置 Intent intent = new Intent( RingtoneManager.ACTION_RINGTONE_PICKER); // 类型为来电RINGTONE intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_RINGTONE); // 设置显示的title intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TITLE, \"设置来电铃声\"); // 当设置完成之后返回到当前的Activity startActivityForResult(intent, CODE_RINGSTONE); &#125; &#125; &#125;); mButtonAlarm.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; if (hasFolder(strAlarmFolder)) &#123; // 打开系统铃声设置 Intent intent = new Intent( RingtoneManager.ACTION_RINGTONE_PICKER); // 设置铃声类型和title intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_ALARM); intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TITLE, \"设置闹钟铃声\"); // 当设置完成之后返回到当前的Activity startActivityForResult(intent, CODE_ALARM); &#125; &#125; &#125;); mButtonNotification.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; if (hasFolder(strNotificationFolder)) &#123; // 打开系统铃声设置 Intent intent = new Intent( RingtoneManager.ACTION_RINGTONE_PICKER); // 设置铃声类型和title intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_NOTIFICATION); intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TITLE, \" 设置通知铃声\"); // 当设置完成之后返回到当前的Activity startActivityForResult(intent, CODE_NOTIFICATION); &#125; &#125; &#125;); &#125; /** * 当设置铃声之后的回调函数 */ @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (resultCode != RESULT_OK) &#123; return; &#125; // 得到我们选择的铃声 Uri pickedUri = data .getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI); if (pickedUri != null) &#123; switch (requestCode) &#123; case CODE_RINGSTONE: // 将我们选择的铃声设置成为默认来电铃声 RingtoneManager.setActualDefaultRingtoneUri(this, RingtoneManager.TYPE_RINGTONE, pickedUri); break; case CODE_ALARM: // 将我们选择的铃声设置成为默认闹钟铃声 RingtoneManager.setActualDefaultRingtoneUri(this, RingtoneManager.TYPE_ALARM, pickedUri); break; case CODE_NOTIFICATION: // 将我们选择的铃声设置成为默认通知铃声 /** * 敲黑板:黑代码解决Android 7.0 调用系统通知无法播放声音的问题 */ grantUriPermission(\"com.android.systemui\", pickedUri, Intent.FLAG_GRANT_READ_URI_PERMISSION); RingtoneManager.setActualDefaultRingtoneUri(this, RingtoneManager.TYPE_NOTIFICATION, pickedUri); break; &#125; &#125; &#125; /** * 检测是否存在指定的文件夹,如果不存在则创建 * * @param strFolder * 文件夹路径 */ private boolean hasFolder(String strFolder) &#123; boolean btmp = false; File f = new File(strFolder); if (!f.exists()) &#123; if (f.mkdirs()) &#123; btmp = true; &#125; else &#123; btmp = false; &#125; &#125; else &#123; btmp = true; &#125; return btmp; &#125;&#125; 希望这篇博客可以带你们入坑~2333333","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"}]},{"title":"JDK7 Collections.sort()方法报错分析","slug":"JDK7CollectionsSortError","date":"2016-12-06T08:53:38.000Z","updated":"2016-12-09T02:24:42.000Z","comments":true,"path":"2016/12/06/JDK7CollectionsSortError/","link":"","permalink":"http://pvphero.github.io/2016/12/06/JDK7CollectionsSortError/","excerpt":"java.lang.IllegalArgumentException: Comparison method violates its general contract!","text":"java.lang.IllegalArgumentException: Comparison method violates its general contract! 问题背景起因前些天测试给提了一个项目里的bug,在查看项目的一个在线数据的列表的时候发生了崩溃.然后我根据bugly定位发现是在使用Collection.sort()对list排序的时候产生Comparison method violates its general contract异常.但是Collection.sort()在JDK1.6中并没有出现过这样的异常啊… 问题定位首先我怀着很纳闷的心情看了下bugly的崩溃日志.有这么一段日志信息 12345678911-23 14:02:55.357 27729 32217 W System.err: java.lang.IllegalArgumentException: Comparison method violates its general contract!11-23 14:02:55.357 27729 32217 W System.err: at java.util.TimSort.mergeLo(TimSort.java:743)11-23 14:02:55.357 27729 32217 W System.err: at java.util.TimSort.mergeAt(TimSort.java:479)11-23 14:02:55.357 27729 32217 W System.err: at java.util.TimSort.mergeCollapse(TimSort.java:406)11-23 14:02:55.357 27729 32217 W System.err: at java.util.TimSort.sort(TimSort.java:210)11-23 14:02:55.357 27729 32217 W System.err: at java.util.TimSort.sort(TimSort.java:169)11-23 14:02:55.357 27729 32217 W System.err: at java.util.Arrays.sort(Arrays.java:2010)11-23 14:02:55.358 27729 32217 W System.err: at java.util.Collections.sort(Collections.java:1883) 然后我定位到出错的代码 12345678910if (list != null &amp;&amp; list.size() &gt; 0)&#123; //降序排序 Collections.sort(list, new Comparator&lt;Spo2Result&gt;() &#123; @Override public int compare(Spo2Result lhs, Spo2Result rhs) &#123; return lhs.getMeasureTime()&gt;rhs.getMeasureTime() ? -1 : 1; &#125; &#125;); &#125; 抛出异常的地方是对一个list按照测量时间降序排序,逻辑很简单.然后我仔仔细细前前后后里里外外的看了好几遍这段代码,为了验证代码的可靠性,我还特意z针对这个排序方法写了一个测试案例,如下: 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class TestSortError &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(); l.add(1); l.add(3); l.add(2); l.add(2); l.add(2); l.add(2); l.add(5); l.add(6); l.add(4); l.add(1); testSort(l); &#125; private static void testSort(List&lt;Integer&gt; l) &#123; Collections.sort(l, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; // TODO Auto-generated method stub return o1 &gt; o2 ? -1 : 1; &#125; &#125;); for (int i = 0; i &lt; l.size(); i++) &#123; System.out.println(l.get(i)); &#125; &#125;&#125; 然后输出: 6 5 4 3 2 2 2 2 1 1 问题分析并没有出现自己脑海中的崩溃现象…于是只能查这个异常,找到了一个有关JDK不兼容的声明. 这个的意思大概是说JDK比较器的排序算法更换了实现方法,新的比较器在违背规则的情况下有可能抛出异常.看到这个就可以确定大概的原因了,因为项目中的排序代码违背了比较器的规则. 于是google了一下比较器的规则: Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.In the foregoing description, the notation sgn(expression) designates the mathematical signum function, which is defined to return one of -1, 0, or 1 according to whether the value ofexpression is negative, zero or positive. The implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (This implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) The implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. Finally, the implementor must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. The recommended language is “Note: this comparator imposes orderings that are inconsistent with equals.” 即满足三个规则: 确保：sgn(compare(x, y)) == -sgn(compare(y, x)). 确保：如果((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0))，那么compare(x, z)&gt;0. 确保：如果compare(x, y)==0，那么对于任意的z都有sgn(compare(x, z))==sgn(compare(y, z))成立. 问题解决代码中出现的三目运算符明显违背了比较器规则,所以把代码稍微改了下,增加了相等情况的判断. 1234567891011if (list != null &amp;&amp; list.size() &gt; 0)&#123; //降序排序 Collections.sort(list, new Comparator&lt;Spo2Result&gt;() &#123; @Override public int compare(Spo2Result lhs, Spo2Result rhs) &#123; return lhs.getMeasureTime()==rhs.getMeasureTime() ?0:(lhs.getMeasureTime()&gt;rhs.getMeasureTime() ? -1 : 1); &#125; &#125;); &#125; 总结使用三目运算符要注意一定要判断相等的情况.否则会违背比较器的规则.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://pvphero.github.io/tags/Java/"}]},{"title":"Mac下关于百度开发者中心认领应用","slug":"ClaimApp","date":"2016-07-11T09:18:21.000Z","updated":"2016-07-11T09:22:04.000Z","comments":true,"path":"2016/07/11/ClaimApp/","link":"","permalink":"http://pvphero.github.io/2016/07/11/ClaimApp/","excerpt":"问题的产生发布一款应用有时因为签名问题,难免会遇到让开发者认领应用的情况.比如说我们公司发布的一款应用发布到360应用市场上,但是却被百度抓包,在我们把应用提交到百度应用平台之前,已经发布…这个时候就需要我们去找回应用了.认领应用其实很简单,无非就是给空包签名.但是有很琐碎,干脆记录下来,以后在遇到直接cv~~","text":"问题的产生发布一款应用有时因为签名问题,难免会遇到让开发者认领应用的情况.比如说我们公司发布的一款应用发布到360应用市场上,但是却被百度抓包,在我们把应用提交到百度应用平台之前,已经发布…这个时候就需要我们去找回应用了.认领应用其实很简单,无非就是给空包签名.但是有很琐碎,干脆记录下来,以后在遇到直接cv~~ 怎么认领 提交需认领应用的PackageName。 下载应用中心提供的未签名包，并将与待认领应用一致的签名写入该包中。 上传完成签名的安装包进行校验。 怎么签名1jarsigner -verbose -keystore your_keystore -signedjar path_of_signed_apk path_of_unsigned_apk your_alias 更改上面引用中的值 your_keystore 你的这个应用签名的keystore的位置 path_of_signed_apk 签名好的空包存放位置 path_of_unsigned_apk 代签名的空包的位置 your_alias 你的keystore的别名 举例比如我的一个应用 1jarsigner -verbose -keystore /Users/seekkou/Desktop/android_studio_key.jks -signedjar /Users/seekkou/Desktop/Baidu_Claim_signed.apk /Users/seekkou/Desktop/Baidu_Claim_unsigned.apk key 参考:应用认领那些事","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"}]},{"title":"Bitmap到底占多少内存","slug":"BitmapOccupyMemory","date":"2016-07-06T10:03:34.000Z","updated":"2016-07-06T10:09:22.000Z","comments":true,"path":"2016/07/06/BitmapOccupyMemory/","link":"","permalink":"http://pvphero.github.io/2016/07/06/BitmapOccupyMemory/","excerpt":"转至:Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？Bugly 技术干货系列内容主要涉及移动开发方向，是由 Bugly 邀请腾讯内部各位技术大咖，通过日常工作经验的总结以及感悟撰写而成，内容均属原创，转载请标明出处。","text":"转至:Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？Bugly 技术干货系列内容主要涉及移动开发方向，是由 Bugly 邀请腾讯内部各位技术大咖，通过日常工作经验的总结以及感悟撰写而成，内容均属原创，转载请标明出处。 写在前面本文涉及到屏幕密度的讨论，这里先要搞清楚 DisplayMetrics 的两个变量，摘录官方文档的解释： density：The logical density of the display. This is a scaling factor for the Density Independent Pixel unit, where one DIP is one pixel on an approximately 160 dpi screen (for example a 240x320, 1.5”x2” screen), providing the baseline of the system’s display. Thus on a 160dpi screen this density value will be 1; on a 120 dpi screen it would be .75; etc.This value does not exactly follow the real screen size (as given by xdpi and ydpi, but rather is used to scale the size of the overall UI in steps based on gross changes in the display dpi. For example, a 240x320 screen will have a density of 1 even if its width is 1.8”, 1.3”, etc. However, if the screen resolution is increased to 320x480 but the screen size remained 1.5”x2” then the density would be increased (probably to 1.5). densityDpi：The screen density expressed as dots-per-inch. 简单来说，可以理解为 density 的数值是 1dp=density px；densityDpi 是屏幕每英寸对应多少个点（不是像素点），在 DisplayMetrics 当中，这两个的关系是线性的： density 1.0 1.5 2.0 3.0 4.0 densityDpi 160 240 320 480 640 为了不引起混淆，本文所有提到的密度除非特别说明，都指的是 densityDpi，当然如果你愿意，也可以用 density 来说明问题。另外，本文的依据主要来自 android 5.0 的源码，其他版本可能略有出入。文章难免疏漏，欢迎指正～ 占了多大内存？做移动客户端开发的朋友们肯定都因为图头疼过，说起来曾经还有过 leader 因为组里面一哥们在工程里面加了一张 jpg 的图发脾气的事儿，哈哈。为什么头疼呢？吃内存呗，时不时还给你来个 OOM 冲冲喜，让你的每一天过得有滋有味（真是没救了）。那每次工程里面增加一张图片的时候，我们都需要关心这货究竟要占多大的坑，占多大呢？Android API 有个方便的方法， 1234public final int getByteCount() &#123; // int result permits bitmaps up to 46,340 x 46,340 return getRowBytes() * getHeight();&#125; 举个列子一张 522x686 的PNG 图片，我把它放到 drawable-xxhdpi 目录下，在三星s6上加载，占用内存2547360B，就可以用这个方法获取到。 给我一张图我告诉你占多大内存每次都问 Bitmap 你到底多大啦。。感觉怪怪的，毕竟我们不能总是去问，而不去搞清楚它为嘛介么大吧。能不能给它算个命，算算它究竟多大呢？当然是可以的，很简单嘛，我们直接顺藤摸瓜，找出真凶，哦不，找出答案。 getByteCountgetByteCount 的源码我们刚刚已经认识了，当我们问 Bitmap 大小的时候，这孩子也是先拿到出生年月日，然后算出来的，那么问题来了，getHeight 就是图片的高度（单位：px），getRowBytes 是什么？ 123456public final int getrowBytes() &#123; if (mRecycled) &#123; Log.w(TAG, \"Called getRowBytes() on a recycle()'d bitmap! This is undefined behavior!\"); &#125; return nativeRowBytes(mFinalizer.mNativeBitmap);&#125; 额，感觉太对了啊，要 JNI 了。由于在下 C++ 实在用得少，每次想起 JNI 都请想象脑门磕墙的场景，不过呢，毛爷爷说过，一切反动派都是纸老虎~与 nativeRowBytes 对应的函数如下：Bitmap.cpp 1234static jint Bitmap_rowBytes(JNIEnv* env, jobject, jlong bitmapHandle) &#123; SkBitmap* bitmap = reinterpret_cast&lt;SkBitmap*&gt;(bitmapHandle) return static_cast&lt;jint&gt;(bitmap-&gt;rowBytes());&#125; 等等，我们好像发现了什么，原来 Bitmap 本质上就是一个 SkBitmap。。而这个 SkBitmap 也是大有来头，不信你瞧：Skia。啥也别说了，赶紧瞅瞅 SkBitmap。 SkBitmap.h12345678910111213141516171819202122232425size_t SkBitmap::ComputeRowBytes(Config c, int width) &#123; return SkColorTypeMinRowBytes(SkBitmapConfigToColorType(c), width);&#125;SkImageInfo.h static int SkColorTypeBytesPerPixel(SkColorType ct) &#123; static const uint8_t gSize[] = &#123; 0, // Unknown 1, // Alpha_8 2, // RGB_565 2, // ARGB_4444 4, // RGBA_8888 4, // BGRA_8888 1, // kIndex_8 &#125;; SK_COMPILE_ASSERT(SK_ARRAY_COUNT(gSize) == (size_t)(kLastEnum_SkColorType + 1), size_mismatch_with_SkColorType_enum); SkASSERT((size_t)ct &lt; SK_ARRAY_COUNT(gSize)); return gSize[ct];&#125; static inline size_t SkColorTypeMinRowBytes(SkColorType ct, int width) &#123; return width * SkColorTypeBytesPerPixel(ct);&#125; 好，跟踪到这里，我们发现 ARGB_8888（也就是我们最常用的 Bitmap 的格式）的一个像素占用 4byte，那么 rowBytes 实际上就是 4width bytes。那么结论出来了，一张 ARGB_8888 的 Bitmap 占用内存的计算公式**bitmapInRam = bitmapWidthbitmapHeight *4 bytes**说到这儿你以为故事就结束了么？有本事你拿去试，算出来的和你获取到的总是会差个倍数，为啥呢？还记得我们最开始给出的那个例子么？ 一张522*686的 PNG 图片，我把它放到 drawable-xxhdpi目录下，在三星s6上加载，占用内存2547360B，就可以用这个方法获取到。 然而公式计算出来的可是1432368B。。。 Density知道我为什么在举例的时候那么费劲的说放到xxx目录下，还要说用xxx手机么？你以为 Bitmap 加载只跟宽高有关么？Naive。还是先看代码，我们读取的是 drawable 目录下面的图片，用的是 decodeResource 方法，该方法本质上就两步： 读取原始资源，这个调用了 Resource.openRawResource 方法，这个方法调用完成之后会对 TypedValue 进行赋值，其中包含了原始资源的 density 等信息； 调用 decodeResourceStream 对原始资源进行解码和适配。这个过程实际上就是原始资源的 density 到屏幕 density 的一个映射。 原始资源的 density 其实取决于资源存放的目录（比如 xxhdpi 对应的是480），而屏幕 density 的赋值，请看下面这段代码： BitmapFactory.java123456789101112131415161718192021222324public static Bitmap decodeResourceStream(Resources res, TypedValue value, InputStream is, Rect pad, Options opts) &#123; //实际上，我们这里的opts是null的，所以在这里初始化。if (opts == null) &#123; opts = new Options();&#125; if (opts.inDensity == 0 &amp;&amp; value != null) &#123; final int density = value.density; if (density == TypedValue.DENSITY_DEFAULT) &#123; opts.inDensity = DisplayMetrics.DENSITY_DEFAULT; &#125; else if (density != TypedValue.DENSITY_NONE) &#123; opts.inDensity = density; //这里density的值如果对应资源目录为hdpi的话，就是240 &#125;&#125; if (opts.inTargetDensity == 0 &amp;&amp; res != null) &#123;//请注意，inTargetDensity就是当前的显示密度，比如三星s6时就是640 opts.inTargetDensity = res.getDisplayMetrics().densityDpi;&#125; return decodeStream(is, pad, opts);&#125; 我们看到 opts 这个值被初始化，而它的构造居然如此简单：12345public Options() &#123; inDither = false; inScaled = true; inPremultiplied = true;&#125; 所以我们就很容易的看到，Option.inScreenDensity 这个值没有被初始化，而实际上后面我们也会看到这个值根本不会用到；我们最应该关心的是什么呢？是 inDensity 和 inTargetDensity，这两个值与下面 cpp 文件里面的 density 和 targetDensity 相对应——重复一下，inDensity 就是原始资源的 density，inTargetDensity 就是屏幕的 density。紧接着，用到了 nativeDecodeStream 方法，不重要的代码直接略过，直接给出最关键的 doDecode 函数的代码： BitmapFactory.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options) &#123; ...... if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123; const int density = env-&gt;GetIntField(options, gOptions_densityFieldID);//对应hdpi的时候，是240 const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID);//三星s6的为640 const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID); if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) &#123; scale = (float) targetDensity / density; &#125; &#125;&#125; const bool willScale = scale != 1.0f;......SkBitmap decodingBitmap;if (!decoder-&gt;decode(stream, &amp;decodingBitmap, prefColorType,decodeMode)) &#123; return nullObjectReturn(\"decoder-&gt;decode returned false\");&#125;//这里这个deodingBitmap就是解码出来的bitmap，大小是图片原始的大小int scaledWidth = decodingBitmap.width();int scaledHeight = decodingBitmap.height();if (willScale &amp;&amp; decodeMode != SkImageDecoder::kDecodeBounds_Mode) &#123; scaledWidth = int(scaledWidth * scale + 0.5f); scaledHeight = int(scaledHeight * scale + 0.5f);&#125;if (willScale) &#123; const float sx = scaledWidth / float(decodingBitmap.width()); const float sy = scaledHeight / float(decodingBitmap.height()); // TODO: avoid copying when scaled size equals decodingBitmap size SkColorType colorType = colorTypeForScaledOutput(decodingBitmap.colorType()); // FIXME: If the alphaType is kUnpremul and the image has alpha, the // colors may not be correct, since Skia does not yet support drawing // to/from unpremultiplied bitmaps. outputBitmap-&gt;setInfo(SkImageInfo::Make(scaledWidth, scaledHeight, colorType, decodingBitmap.alphaType())); if (!outputBitmap-&gt;allocPixels(outputAllocator, NULL)) &#123; return nullObjectReturn(\"allocation failed for scaled bitmap\"); &#125; // If outputBitmap's pixels are newly allocated by Java, there is no need // to erase to 0, since the pixels were initialized to 0. if (outputAllocator != &amp;javaAllocator) &#123; outputBitmap-&gt;eraseColor(0); &#125; SkPaint paint; paint.setFilterLevel(SkPaint::kLow_FilterLevel); SkCanvas canvas(*outputBitmap); canvas.scale(sx, sy); canvas.drawBitmap(decodingBitmap, 0.0f, 0.0f, &amp;paint);&#125;......&#125; 注意到其中有个 density 和 targetDensity，前者是 decodingBitmap 的 density，这个值跟这张图片的放置的目录有关（比如 hdpi 是240，xxhdpi 是480），这部分代码我跟了一下，太长了，就不列出来了；targetDensity 实际上是我们加载图片的目标 density，这个值的来源我们已经在前面给出了，就是 DisplayMetrics 的 densityDpi，如果是三星s6那么这个数值就是640。sx 和sy 实际上是约等于 scale 的，因为 scaledWidth 和 scaledHeight 是由 width 和 height 乘以 scale 得到的。我们看到 Canvas 放大了 scale 倍，然后又把读到内存的这张 bitmap 画上去，相当于把这张 bitmap 放大了 scale 倍。 再来看我们的例子： 一张522*686的PNG 图片，我把它放到 drawable-xxhdpi 目录下，在三星s6上加载，占用内存2547360B，其中density 对应 xxhdpi 为480，targetDensity 对应三星s6的密度为640： 522/480 640 686/480 640 4 = 2546432B 精度越来越有趣了是不是，你肯定会发现我们这么细致的计算还是跟获取到的数值不！一！样！为什么呢？由于结果已经非常接近，我们很自然地想到精度问题。来，再把上面这段代码中的一句拿出来看看： 12outputBitmap-&gt;setInfo(SkImageInfo::Make(scaledWidth, scaledHeight, colorType, decodingBitmap.alphaType())); 我们看到最终输出的 outputBitmap 的大小是scaledWidth*scaledHeight，我们把这两个变量计算的片段拿出来给大家一看就明白了： 1234if (willScale &amp;&amp; decodeMode != SkImageDecoder::kDecodeBounds_Mode) &#123; scaledWidth = int(scaledWidth * scale + 0.5f); scaledHeight = int(scaledHeight * scale + 0.5f);&#125; 在我们的例子中，scaledWidth = int( 522 * 640 / 480f + 0.5) = int(696.5) = 696scaledHeight = int( 686 * 640 / 480f + 0.5) = int(915.16666…) = 915下面就是见证奇迹的时刻：915 696 4 = 2547360有木有很兴奋！有木有很激动！！写到这里，突然想起《STL源码剖析》一书的扉页，侯捷先生只写了一句话： “源码之前，了无秘密” 小结其实，通过前面的代码跟踪，我们就不难知道，Bitmap 在内存当中占用的大小其实取决于： 色彩格式，前面我们已经提到，如果是 ARGB8888 那么就是一个像素4个字节，如果是 RGB565 那就是2个字节 原始文件存放的资源目录（是 hdpi 还是 xxhdpi 可不能傻傻分不清楚哈） 目标屏幕的密度（所以同等条件下，红米在资源方面消耗的内存肯定是要小于三星S6的） 想办法减少 Bitmap 内存占用Jpg 和 Png说到这里，肯定会有人会说，我们用 jpg 吧，jpg 格式的图片不应该比 png 小么？这确实是个好问题，因为同样一张图片，jpg 确实比 png 会多少小一些（甚至很多），原因很简单，jpg 是一种有损压缩的图片存储格式，而 png 则是 无损压缩的图片存储格式，显而易见，jpg 会比 png 小，代价也是显而易见的。 可是，这说的是文件存储范畴的事情，它们只存在于文件系统，而非内存或者显存。说得简单一点儿，我有一个极品飞车的免安装硬盘版的压缩包放在我的磁盘里面，这个游戏是不能玩的，我需要先解压，才能玩——jpg 也好，png 也好就是个压缩包的概念，而我们讨论的内存占用则是从使用角度来讨论的。所以，jpg 格式的图片与 png 格式的图片在内存当中不应该有什么不同。 『啪！！！』 『谁这么缺德！！打人不打脸好么！』 肯定有人有意见，jpg 图片读到内存就是会小，还会给我拿出例子。当然，他说的不一定是错的。因为 jpg 的图片没有 alpha 通道！！所以读到内存的时候如果用 RGB565的格式存到内存，这下大小只有 ARGB8888的一半，能不小么。。。不过，抛开 Android 这个平台不谈，从出图的角度来看的话，jpg 格式的图片大小也不一定比 png 的小，这要取决于图像信息的内容： JPG 不适用于所含颜色很少、具有大块颜色相近的区域或亮度差异十分明显的较简单的图片。对于需要高保真的较复杂的图像，PNG 虽然能无损压缩，但图片文件较大。 如果仅仅是为了 Bitmap 读到内存中的大小而考虑的话，jpg 也好 png 也好，没有什么实质的差别；二者的差别主要体现在： alpha 你是否真的需要？如果需要 alpha 通道，那么没有别的选择，用 png。 你的图色值丰富还是单调？就像刚才提到的，如果色值丰富，那么用jpg，如果作为按钮的背景，请用 png。 对安装包大小的要求是否非常严格？如果你的 app 资源很少，安装包大小问题不是很凸显，看情况选择 jpg 或者 png（不过，我想现在对资源文件没有苛求的应用会很少吧。。） 目标用户的 cpu 是否强劲？jpg 的图像压缩算法比 png 耗时。这方面还是要酌情选择，前几年做了一段时间 Cocos2dx，由于资源非常多，项目组要求统一使用 png，可能就是出于这方面的考虑。 嗯，跑题了，我们其实想说的是怎么减少内存占用的。。这一小节只是想说，休想通过这个方法来减少内存占用。。。XD 使用 inSampleSize有些朋友一看到这个肯定就笑了。采样嘛，我以前是学信号处理的，一看到 Sample 就抽抽。。哈哈开个玩笑，这个采样其实就跟统计学里面的采样是一样的，在保证最终效果满足要求的前提下减少样本规模，方便后续的数据采集和处理。这个方法主要用在图片资源本身较大，或者适当地采样并不会影响视觉效果的条件下，这时候我们输出地目标可能相对较小，对图片分辨率、大小要求不是非常的严格。 举个例子我们现在有个需求，要求将一张图片进行模糊，然后作为 ImageView 的 src 呈现给用户，而我们的原始图片大小为 1080*1920，如果我们直接拿来模糊的话，一方面模糊的过程费时费力，另一方面生成的图片又占用内存，实际上在模糊运算过程中可能会存在输入和输出并存的情况，此时内存将会有一个短暂的峰值。这时候你一定会想到三个字母在你的脑海里挥之不去，它们就是『OOM』。既然图片最终是要被模糊的，也看不太情况，还不如直接用一张采样后的图片，如果采样率为 2，那么读出来的图片只有原始图片的 1/4 大小，真是何乐而不为呢？？123BitmapFactory.Options options = new Options();options.inSampleSize = 2;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), resId, options); 使用矩阵用到 Bitmap 的地方，总会见到 Matrix。这时候你会想到什么？ 『基友』 『是在下输了。。』 其实想想，Bitmap 的像素点阵，还不就是个矩阵，真是你中有我，我中有你的交情啊。那么什么时候用矩阵呢？ 大图小用用采样，小图大用用矩阵。还是用前面模糊图片的例子，我们不是采样了么？内存是小了，可是图的尺寸也小了啊，我要用 Canvas 绘制这张图可怎么办？当然是用矩阵了：方式一： 12345Matrix matrix = new Matrix();matrix.preScale(2, 2, 0f, 0f);//如果使用直接替换矩阵的话，在Nexus6 5.1.1上必须关闭硬件加速canvas.concat(matrix);canvas.drawBitmap(bitmap, 0,0, paint); 需要注意的是，在使用搭载 5.1.1 原生系统的 Nexus6 进行测试时发现，如果使用 Canvas 的 setMatrix 方法，可能会导致与矩阵相关的元素的绘制存在问题，本例当中如果使用 setMatrix 方法，bitmap 将不会出现在屏幕上。因此请尽量使用 canvas 的 scale、rotate 这样的方法，或者使用 concat 方法。 方式二：123Matrix matrix = new Matrix();matrix.preScale(2, 2, 0, 0);canvas.drawBitmap(bitmap, matrix, paint); 这样，绘制出来的图就是放大以后的效果了，不过占用的内存却仍然是我们采样出来的大小。如果我要把图片放到 ImageView 当中呢？一样可以，请看：12345Matrix matrix = new Matrix();matrix.postScale(2, 2, 0, 0);imageView.setImageMatrix(matrix);imageView.setScaleType(ScaleType.MATRIX);imageView.setImageBitmap(bitmap); 合理选择Bitmap的像素格式其实前面我们已经多次提到这个问题。ARGB8888格式的图片，每像素占用 4 Byte，而 RGB565则是 2 Byte。我们先看下有多少种格式可选：| 格式 | 描述 || - | :-||ALPHA_8| 只有一个alpha通道 ||ARGB_4444 | 这个从API 13开始不建议使用，因为质量太差||ARGB_8888 | ARGB四个通道，每个通道8bit ||RGB_565 |每个像素占2Byte，其中红色占5bit，绿色占6bit，蓝色占5bit | 这几个当中，ALPHA8 没必要用，因为我们随便用个颜色就可以搞定的。ARGB4444 虽然占用内存只有 ARGB8888 的一半，不过已经被官方嫌弃，失宠了。。『又要占省内存，又要看着爽，臣妾做不到啊T T』。ARGB8888 是最常用的，大家应该最熟悉了。RGB565 看到这个，我就看到了资源优化配置无处不在，这个绿色。。（不行了，突然好邪恶XD），其实如果不需要 alpha 通道，特别是资源本身为 jpg 格式的情况下，用这个格式比较理想。 高能：索引位图(Indexed Bitmap)索引位图，每个像素只占 1 Byte，不仅支持 RGB，还支持 alpha，而且看上去效果还不错！等等，请收起你的口水，Android 官方并不支持这个。是的，你没看错，官方并不支持。12345678910public enum Config &#123; // these native values must match up with the enum in SkBitmap.h ALPHA_8 (2), RGB_565 (4), ARGB_4444 (5), ARGB_8888 (6); final int nativeInt;&#125; 不过，Skia 引擎是支持的，不信你再看：12345678910111213enum Config &#123; kNo_Config, //!&lt; bitmap has not been configured kA8_Config, //!&lt; 8-bits per pixel, with only alpha specified (0 is transparent, 0xFF is opaque) //看这里看这里！！↓↓↓↓↓ kIndex8_Config, //!&lt; 8-bits per pixel, using SkColorTable to specify the colors kRGB_565_Config, //!&lt; 16-bits per pixel, (see SkColorPriv.h for packing) kARGB_4444_Config, //!&lt; 16-bits per pixel, (see SkColorPriv.h for packing) kARGB_8888_Config, //!&lt; 32-bits per pixel, (see SkColorPriv.h for packing) kRLE_Index8_Config, kConfigCount&#125;; 其实 Java 层的枚举变量的 nativeInt 对应的就是 Skia 库当中枚举的索引值，所以，如果我们能够拿到这个索引是不是就可以了？对不起，拿不到。不行了，废话这么多，肯定要挨板砖了T T。不过呢，在 png 的解码库里面有这么一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041bool SkPNGImageDecoder::getBitmapColorType(png_structp png_ptr, png_infop info_ptr, SkColorType* colorTypep, bool* hasAlphap, SkPMColor* SK_RESTRICT theTranspColorp) &#123;png_uint_32 origWidth, origHeight;int bitDepth, colorType;png_get_IHDR(png_ptr, info_ptr, &amp;origWidth, &amp;origHeight, &amp;bitDepth, &amp;colorType, int_p_NULL, int_p_NULL, int_p_NULL); #ifdef PNG_sBIT_SUPPORTED // check for sBIT chunk data, in case we should disable dithering because // our data is not truely 8bits per component png_color_8p sig_bit; if (this-&gt;getDitherImage() &amp;&amp; png_get_sBIT(png_ptr, info_ptr, &amp;sig_bit)) &#123;#if 0 SkDebugf(\"----- sBIT %d %d %d %d\\n\", sig_bit-&gt;red, sig_bit-&gt;green, sig_bit-&gt;blue, sig_bit-&gt;alpha);#endif // 0 seems to indicate no information available if (pos_le(sig_bit-&gt;red, SK_R16_BITS) &amp;&amp; pos_le(sig_bit-&gt;green, SK_G16_BITS) &amp;&amp; pos_le(sig_bit-&gt;blue, SK_B16_BITS)) &#123; this-&gt;setDitherImage(false); &#125;&#125;#endif if (colorType == PNG_COLOR_TYPE_PALETTE) &#123; bool paletteHasAlpha = hasTransparencyInPalette(png_ptr, info_ptr); *colorTypep = this-&gt;getPrefColorType(kIndex_SrcDepth, paletteHasAlpha); // now see if we can upscale to their requested colortype //这段代码，如果返回false，那么colorType就被置为索引了，那么我们看看如何返回false if (!canUpscalePaletteToConfig(*colorTypep, paletteHasAlpha)) &#123; *colorTypep = kIndex_8_SkColorType; &#125;&#125; else &#123;...... &#125;return true;&#125; canUpscalePaletteToConfig 函数如果返回false，那么 colorType 就被置为 kIndex_8_SkColorType 了。 123456789101112static bool canUpscalePaletteToConfig(SkColorType dstColorType, bool srcHasAlpha) &#123; switch (dstColorType) &#123; case kN32_SkColorType: case kARGB_4444_SkColorType: return true; case kRGB_565_SkColorType: // only return true if the src is opaque (since 565 is opaque) return !srcHasAlpha; default: return false;&#125;&#125; 如果传入的 dstColorType 是 kRGB_565_SkColorType，同时图片还有 alpha 通道，那么返回 false~~咳咳，那么问题来了，这个dstColorType 是哪儿来的？？就是我们在 decode 的时候，传入的 Options 的 inPreferredConfig。 下面是实验时间~准备：在 assets 目录当中放了一个叫 index.png 的文件，大小192*192，这个文件是通过 PhotoShop 编辑之后生成的索引格式的图片。代码： 12345678910try &#123; Options options = new Options(); options.inPreferredConfig = Config.RGB_565;Bitmap bitmap = BitmapFactory.decodeStream(getResources().getAssets().open(\"index.png\"), null, options); Log.d(TAG, \"bitmap.getConfig() = \" + bitmap.getConfig()); Log.d(TAG, \"scaled bitmap.getByteCount() = \" + bitmap.getByteCount()); imageView.setImageBitmap(bitmap);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 程序运行在 Nexus6上，由于从 assets 中读取不涉及前面讨论到的 scale 的问题，所以这张图片读到内存以后的大小理论值（ARGB8888）：192 192 4=147456 好，运行我们的代码，看输出的 Config 和 ByteCount： 先说大小为什么只有 36864，我们知道如果前面的讨论是没有问题的话，那么这次解码出来的 Bitmap 应该是索引格式，那么占用的内存只有 ARGB 8888 的1/4是意料之中的；再说 Config 为什么为 null。。额。。黑户。。官方说： public final Bitmap.Config getConfig () Added in API level 1 If the bitmap’s internal config is in one of the public formats, return that config, otherwise return null. 再说一遍，黑户。。XD。看来这个法子还真行啊，占用内存一下小很多。不过由于官方并未做出支持，因此这个方法有诸多限制，比如不能在 xml 中直接配置，，生成的 Bitmap 不能用于构建 Canvas 等等。 不要辜负。。。『哦，不要姑父！』其实我们一直在抱怨资源大，有时候有些场景其实不需要图片也能完成的。比如在开发中我们会经常遇到 Loading，这些 Loading 通常就是几帧图片，图片也比较简单，只需要黑白灰加 alpha 就齐了。 『排期太紧了，这些给我出一系列图吧』 『好，不过每张图都是 300*30 0的 png 哈，总共 5 张，为了适配不同的分辨率，需要出 xxhdpi 和 xxxhdpi 的两套图。。』 Orz。。。如果是这样，你还是自定义一个 View，覆写 onDraw 自己画一下好了。。。 结语写了这么多，我们来稍稍理一理，本文主要讨论了如何运行时获取 Bitmap 占用内存的大小，如果事先根据 Bitmap 的格式、读取方式等算出其占用内存的大小，后面又整理了一些常见的 Bitmap 使用建议。突然好像说，是时候研究一下 Skia 引擎了。怎么办，看来扔了好几年的 C++还是要捡回来么。。噗。。。 内容转至:Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://pvphero.github.io/tags/Bitmap/"}]},{"title":"Android IllegalStateException: Fragment not attached to Activity","slug":"Android-IllegalStateException-Fragment-not-attached-to-Activity","date":"2016-07-04T07:22:29.000Z","updated":"2016-07-04T07:40:40.000Z","comments":true,"path":"2016/07/04/Android-IllegalStateException-Fragment-not-attached-to-Activity/","link":"","permalink":"http://pvphero.github.io/2016/07/04/Android-IllegalStateException-Fragment-not-attached-to-Activity/","excerpt":"12java.lang.IllegalStateExceptionFragment QuestionCollectSimpleFragment&#123;42283040&#125; not attached to Activity","text":"12java.lang.IllegalStateExceptionFragment QuestionCollectSimpleFragment&#123;42283040&#125; not attached to Activity 问题的产生项目中,加载一个fragment,然后迅速点击系统自带的返回或者自带的返回按钮弹出提示时自动退出. 异常分析定位代码发现,该问题的产生的原因是在调用资源文件getResource()时发生的crash. 该问题产生的原因是因为fragment加载的时候还没有Attach到他所被管理的activity上就去加载Resource导致的. 解决方法在调用getResource()方法时判断下改fragment是否attach到他所管理的activity上.使用isAdded() 方法.123if(isAdded())&#123; getResources().getString(R.string.xxx);&#125;","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"fragment","slug":"fragment","permalink":"http://pvphero.github.io/tags/fragment/"}]},{"title":"使用命令行给Git项目加上tag","slug":"AddGitTag","date":"2016-07-04T06:53:04.000Z","updated":"2016-07-04T07:00:18.000Z","comments":true,"path":"2016/07/04/AddGitTag/","link":"","permalink":"http://pvphero.github.io/2016/07/04/AddGitTag/","excerpt":"我们在提交git项目的时候,有时候需要给项目的版本加上标签,我们需要用到以下命令给代码加上标签.","text":"我们在提交git项目的时候,有时候需要给项目的版本加上标签,我们需要用到以下命令给代码加上标签.12$ git tag -a &quot;V2.3.3&quot; -m &quot;change version name&quot; $ git push --tags 运行结果12345Counting objects: 1, done.Writing objects: 100% (1/1), 168 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@123.57.148.160:/home/git/android/GradleCommonTeacher.git * [new tag] V2.3.3 -&gt; V2.3.3 然后我们看一下提交工作流1$ gitk ok~可以看到tag已经提交上去了~","categories":[{"name":"Git","slug":"Git","permalink":"http://pvphero.github.io/categories/Git/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://pvphero.github.io/tags/Android-Studio/"},{"name":"Git","slug":"Git","permalink":"http://pvphero.github.io/tags/Git/"}]},{"title":"怎么去除android listview的默认点击效果","slug":"RemoveAndroidListviewDefaultClickEffect","date":"2016-05-12T09:18:21.000Z","updated":"2016-07-04T07:07:48.000Z","comments":true,"path":"2016/05/12/RemoveAndroidListviewDefaultClickEffect/","link":"","permalink":"http://pvphero.github.io/2016/05/12/RemoveAndroidListviewDefaultClickEffect/","excerpt":"在做项目的时候会遇到listview点击item的时候出现黄色的默认的点击效果.但是项目中不要出现这个效果.贴上正确的方法,只需要在listview的布局文件中加上","text":"在做项目的时候会遇到listview点击item的时候出现黄色的默认的点击效果.但是项目中不要出现这个效果.贴上正确的方法,只需要在listview的布局文件中加上1android:listSelector=\"@android:color/transparent\" 做个笔记记下来~~","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"ListView","slug":"ListView","permalink":"http://pvphero.github.io/tags/ListView/"}]},{"title":"Android使用Intent跳转的时候,如何清除堆栈里所有的Activity","slug":"AndroidIntentJump","date":"2016-04-27T03:27:17.000Z","updated":"2016-04-27T03:31:28.000Z","comments":true,"path":"2016/04/27/AndroidIntentJump/","link":"","permalink":"http://pvphero.github.io/2016/04/27/AndroidIntentJump/","excerpt":"我在开发一块下单送货软件的时候遇到的这个问题.场景描述,用户从首页选择里订单,进入了订单确认页面,确认后进入了选择支付页面,支付成功以后需要返回首页.如何在进入首页的时候清除堆栈里所有的Activity?说说有效的方法吧.FLAG_ACTIVITY_CLEAR_TOP","text":"我在开发一块下单送货软件的时候遇到的这个问题.场景描述,用户从首页选择里订单,进入了订单确认页面,确认后进入了选择支付页面,支付成功以后需要返回首页.如何在进入首页的时候清除堆栈里所有的Activity?说说有效的方法吧.FLAG_ACTIVITY_CLEAR_TOP12Intent intent = new Intent(A.this,B.class).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 看看里面的安卓源码12345678/** * If set in an Intent passed to &#123;@link Context#startActivity Context.startActivity()&#125;, * this flag will cause any existing task that would be associated with the * activity to be cleared before the activity is started. That is, the activity * becomes the new root of an otherwise empty task, and any old activities * are finished. This can only be used in conjunction with &#123;@link #FLAG_ACTIVITY_NEW_TASK&#125;. */ public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000; 源码中明确说明如果在startActivity的时候传递FLAG_ACTIVITY_CLEAR_TASK这个标志,那么这个标志将会清除之前所有已经打开的activity.然后将会变成另外一个空栈的root,然后其他的Activitys就都被关闭了.这个方法必须跟着{@link #FLAG_ACTIVITY_NEW_TASK}一起使用. 我的博客地址GitHub BlogCoding BlogCSDN Blog","categories":[{"name":"Android开发笔记","slug":"Android开发笔记","permalink":"http://pvphero.github.io/categories/Android开发笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://pvphero.github.io/tags/Android/"},{"name":"Intent","slug":"Intent","permalink":"http://pvphero.github.io/tags/Intent/"},{"name":"setFlags","slug":"setFlags","permalink":"http://pvphero.github.io/tags/setFlags/"}]},{"title":"如何将Hexo Blog同时发布到GitHub跟Coding上","slug":"PushHexoBlogToGitHubAndCoding","date":"2016-04-24T17:22:44.000Z","updated":"2018-01-19T07:32:54.000Z","comments":true,"path":"2016/04/25/PushHexoBlogToGitHubAndCoding/","link":"","permalink":"http://pvphero.github.io/2016/04/25/PushHexoBlogToGitHubAndCoding/","excerpt":"前言上一篇文章已经讲过怎样使用Hexo建立博客以及怎样将Hexo博客发布到GitHub上.如果对Hexo建立博客还不熟悉请先看看之前的那篇文章我的Hexo博客建站日志.大家可能跟我一样,建站的时候很轻松,但是等往github上提交的时候会等待很长时间,毕竟GitHub是国外的东西,很多地方会被墙掉,在我们现在不翻墙的情况下如何能将自己的博客迅速的托管到免费平台上呢?于是我想到了我比较喜欢保存自己项目的Coding.net.一款国内的,强大的代码托管,项目演示平台.平台找到了,但又如何能不费劲一次就同时部署到Coding.net跟GitHub上呢?于是带着这两个问题,我查了很多资料,又经过一番折腾,终于实现了,一次部署同时发布.","text":"前言上一篇文章已经讲过怎样使用Hexo建立博客以及怎样将Hexo博客发布到GitHub上.如果对Hexo建立博客还不熟悉请先看看之前的那篇文章我的Hexo博客建站日志.大家可能跟我一样,建站的时候很轻松,但是等往github上提交的时候会等待很长时间,毕竟GitHub是国外的东西,很多地方会被墙掉,在我们现在不翻墙的情况下如何能将自己的博客迅速的托管到免费平台上呢?于是我想到了我比较喜欢保存自己项目的Coding.net.一款国内的,强大的代码托管,项目演示平台.平台找到了,但又如何能不费劲一次就同时部署到Coding.net跟GitHub上呢?于是带着这两个问题,我查了很多资料,又经过一番折腾,终于实现了,一次部署同时发布. 在Coding上创建一个项目准备工作首先打开个账户的个人设置中找到Global Key(个性后缀),然后新建一个Coding项目,项目名字跟Global Key相同.(大家也可以不这么建,可以直接建立项目,但是最后生成的页面会很长,显得不美观) Tips: 最好创建跟Global Key相同的项目这样访问起来直接就是http://yourGlobalKey.coding.me. 比如说我的Coding的博客CodingBlog,否则的话后面得加上项目名. 这里创建的是公有项目,为什么要创建公有项目,是因为如果项目弄成私有的,那么你的项目的pages页面就看不到里面的js效果了,就是只有文字的那种,主题什么的都白设置了. 如果项目已经设置成私有项目了并且还想看到效果,那只能用coding的演示功能了.只是coding功能是需要花费码币的,24小时0.01码币. 如果项目设置成公有的项目了,然后也部署成功了,在手机上打开的时候建议使用腾讯内核外的浏览器,否则的话可能会被当成恶意网站屏蔽掉.在pc上任何浏览器打开都是没问题的.配置CodingGit的SSH如果是第一次使用CodingGit提交的话,建议先配置SSH公匙.Coding生成公匙的方法可以查看配置CodingSSH公钥.如果陌生可以按以下步骤来: 打开个人中心的SSH公匙 如果之前配置过GitHub的公匙的话直接打开,.ssh文件夹里面的_rsa.pub比如我的是pvphero_rsa.pub,然后将里面的内容全部复制,填写到ssh_rsa公匙处,公匙的名称可以随便起,然后点击’添加’,再接着输入密码就可以完成添加了 添加后测试一下1ssh -T git@git.coding.net 如果出现下面的提示则表示公匙添加成功了:1Hello shenzhenwei You&apos;ve connected to Coding.net by SSH successfully! 配置_config.yml的部署准备工作都做好了,现在开始配置_config.yml,大家经过前面的文章我的Hexo博客建站日志相信对发布到GitHub上并不陌生,发布到GitHub上是在_config.yml文件中的deploy加上了GitHub的项目地址,以及发布的分支.那么要想同时发布到Coding上肯定是需要在配置文件中加上Coding的项目地址的,但是应该怎么加?格式又是如何呢?,根据Hexo官方文档只需要将deploy的格式更改成下面的就可以了12345deploy: type: git repo: github: &lt;repository url&gt;,[branch] coding: &lt;repository url&gt;,[branch] 比如我的是这样的:12345deploy: type: git repo: github: git@github.com:pvphero/pvphero.github.io.git,master coding: git@git.coding.net:shenzhenwei/shenzhenwei.git,master 部署Hexo博客部署到GitHub跟Coding 前面的工作都做好了以后,生成静态网页 1$ hexo g 本地查看效果 1$ hexo s 部署到git 1$ sudo hexo d 之后我们可以看到Coding跟GitHub中项目有我们提交上来的代码并且GitHub上已经可以看到发布的内容Github Blog 设置Coding项目中的配置在Coding上部署博客有两种方式,前面提到过,在做下说明.Coding上部署博客总共有两种: 通过coding pages的方式进行博客的部署.coding为每个项目都推出了pages,不管是公有的还是私有的都有pages功能.我也比较推荐这种方式去搭建Hexo Coding博客.有很多好处,比如说免费,比如说可以绑定域名等等吧. 通过Coding的演示功能进行Hexo Coding博客的部署.这种方式是收费的,每天最少0.01码币,大家可以体验体验.但不推荐.如果采用Pages方式的话就必须要在source/新建一个空白文件,名字必须是Staticfile12cd sourcetouch Staticfile #名字必须是Staticfile 因为用过coding演示功能的小伙伴都可能会知道,如果演示的时候没有Staticfile,coding的检测会提示检测不到,询问你是否强制开启.具体的原因的话,可能是coding是用静态的方式部署的,检测到这个的时候就知道你的项目是以静态方式发布的. 开启coding项目的pages功能在刚刚建的项目中开启pages功能,这里的部署分支选择master,因为你在_config.yml中设置的分支是master,然后点击立即开启.这时候如果点击链接出现404的话,并且本地测试是没有问题的,github上打开的链接也是没有问题的话,那么久需要耐心的多等几分钟了,这个coding.net部署的稍微慢点.coding的博客部署就ok了.这样就可以提交一次同时部署了~~ 演示方式部署关于演示方式部署,我就不费口舌了,因为演示方式部署肯定支持静态网页的,不管你是私有项目还是公有项目都是可以看到的.如果实在想去进行网站部署,建议大家参看 嘟嘟MD 希望这篇文章对大家有所帮助~~我也是看了 嘟嘟MD 的博客,然后跟着一步一步实现的~希望大家有问题多交流~ 本文参与 Coding 征文计划","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://pvphero.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://pvphero.github.io/tags/GitHub/"},{"name":"Coding","slug":"Coding","permalink":"http://pvphero.github.io/tags/Coding/"}]},{"title":"我的Hexo博客建站日志","slug":"MyHexoBlogWebsiteRecord","date":"2016-04-23T19:01:23.000Z","updated":"2016-04-24T04:33:14.000Z","comments":true,"path":"2016/04/24/MyHexoBlogWebsiteRecord/","link":"","permalink":"http://pvphero.github.io/2016/04/24/MyHexoBlogWebsiteRecord/","excerpt":"前言我是一枚安卓猿,js css以及基于Nodejs的Hexo对我来说完全是个新领域.由于之前查资料查到看到一个人的博客很不错MOxFIVE,于是就决定模仿人家的博客进行搭建自己的Hexo博客.程序员就是爱折腾.于是查了很多资料,最终实现了自己的Hexo博客.下面我就把一个完全不懂nodejs以及之前根本没听说过Hexo的人建站的历程给大家分享下. 我是在Mac环境下搭建的,Win环境跟Mac的差不多,如果大家是win环境,我建议大家参看粉丝日志","text":"前言我是一枚安卓猿,js css以及基于Nodejs的Hexo对我来说完全是个新领域.由于之前查资料查到看到一个人的博客很不错MOxFIVE,于是就决定模仿人家的博客进行搭建自己的Hexo博客.程序员就是爱折腾.于是查了很多资料,最终实现了自己的Hexo博客.下面我就把一个完全不懂nodejs以及之前根本没听说过Hexo的人建站的历程给大家分享下. 我是在Mac环境下搭建的,Win环境跟Mac的差不多,如果大家是win环境,我建议大家参看粉丝日志 Hexo 介绍Hexo 是一个简单的,轻量级,基于Nodejs的一个静态的博客框架.我们可以很方便的使用Hexo搭建个人博客. 对一个外行来说,在一开始使用Hexo的时候心理难免有很多疑问.那我来说,我刚接触Hexo的时候我一直在想:Hexo到底是什么?他是如何把网站部署到github或者conding上的?Hexo怎么进行博客内容的编辑啊?于是经过几番折腾,我对Hexo有了初步的了解.希望我的理解对大家刚刚搭建有所帮助吧. 首先,Hexo是一个基于Nodejs的框架,我们通过Hexo里面的命令在Vim上进行hexo初始化,hexo生成index.html静态页面,然后再通过命令发布到github或者conding Hexo里面集成有git的插件,所以你发布到你的 yourname.github.io的时候只需要把_config.yml中的配置配置好.然后使用12$ hexo g$ hexo d 就可以将通过Hexo编译好的文件推送到git项目中 hexo里面的内容怎么编辑?hexo里面的文件是以md结尾的.是markdown语法.所以大家编辑的时候可以先看看markdown语法.我这边是使用的mac的Mou一款免费的markdown软件.大家也可以使用phpStorm,里面在plugins中可以下载markdown的插件.建议大家下载个PHPStorm IDE,因为将来涉及到图片更换,主题更换,目录结构的查看等等,都会比较直观. 配置环境 安装Node (必须) 作用是用来生成静态页面.到Node.js官网上下载相应平台的最新版本,一路安装即可,没有难度…此处略过!但是一定要装啊. 安装Git (必须) 作用是把本地hexo内容提交到git上去,安装xcode就自带Git了,就不多说了~ 申请Github(想同时发布到coding上的,可以再申请个coding账号,后面会讲到) 配置github SSH keys(可以不配置,不配置的话就的每次提交的时候手动输入账号密码了,如果配置了就不需要了,就会很方便)GitHub-Help-SSH配置 Hexo的安装系统环境 Mac OS Hexo安装,要用全局安装,加参数-g $ sudo npm install-g hexo 查看Hexo的版本 $ hexo version hexo-cli: 1.0.1 os: Darwin 14.5.0 darwin x64 http_parser: 2.5.2 node: 4.4.3 v8: 4.5.103.35 uv: 1.8.0 zlib: 1.2.8 ares: 1.10.1-DEV icu: 56.1 modules: 46 openssl: 1.0.2g 或者 $ hexo v hexo-cli: 1.0.1 os: Darwin 14.5.0 darwin x64 http_parser: 2.5.2 node: 4.4.3 v8: 4.5.103.35 uv: 1.8.0 zlib: 1.2.8 ares: 1.10.1-DEV icu: 56.1 modules: 46 openssl: 1.0.2g 这个时候可能会出现 { [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; } 解决方法 $ npm install hexo --no-optional 参考Hexo常见问题解决方案 安装好以后我们就可以使用Hexo创建项目了 $ hexo init nodejs-blog 然后我们打开Finder发现,刚刚的路径下多了一个文件夹,并且文件夹有Hexo相应的初始化模块. 初始化完成后进入刚刚创建的文件夹,并启动服务器,看看效果 进入刚刚创建的文件夹 $ cd nodejs-blog/ $ ls -a . .gitignore _config.yml package.json source .. .npmignore node_modules scaffolds themes 启动hexo服务器查看效果 $ hexo s INFO Start processing INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 然后通过浏览器访问 http://0.0.0.0:4000/查看效果 Hexo 目录结构及用法4.1目录结构 scaffolds 脚手架，也就是一个工具模板 source 存放博客正文内容 比如说我们新建一个page 那么改page就会出现在这个文件中,我们如果想对原先的博客进行修改的话,就打开这个文件夹下相应的文件进行编辑.如果是想删除的话,那就直接删除该文件夹下相应的文件 themes 存放皮肤的目录 用户可以根据自己的喜好更换_config.yml中的themes _config.yml全局的配置文件 db.json 静态常量 4.2全局变量_config.yml的配置 站点信息: 定义标题，作者，语言 URL: URL访问路径 文件目录: 正文的存储目录 写博客配置：文章标题，文章类型，外部链接等 目录和标签：默认分类，分类图，标签图 归档设置：归档的类型 服务器设置：IP，访问端口，日志输出 时间和日期格式： 时间显示格式，日期显示格式 分页设置：每页显示数量 评论：外挂的Disqus评论系统 插件和皮肤：换皮肤，安装插件 Markdown语言：markdown的标准 CSS的stylus格式：是否允许压缩 部署配置：github发布 编辑_config.yml文件 $ vim _config.yml 4.3创建新的文章 $ hexo new 我的第一篇Hexo博客 启动服务器 4.4文章语法 Markdown语法 怎样引导新手使用 Markdown？ 实例: title: 新的开始 date: 2014-05-07 18:44:12 permalink: abc tags: - 开始 - 我 - 日记 categories: - 日志 - 第一天 --- 这是**新的开始**，我用hexo创建了第一篇文章。 通过下面的命令，就可以创建新文章 1$ hexo new 我的第一篇Hexo博客 感觉非常好。 发布到Github上5.1生成静态的index.thml文件 $ hexo g 5.2创建githb pages 在Github上创建一个项目 username.github.io 比如我的用户名是pvphero 那么我创建的项目的名字就是pvphero.github.io pvphero’s GitHub 参考GitHubPages 然后可能有人觉得访问github过慢,有什么好的解决方法么? github访问慢的原因是因为CDN: github.global.ssl.fastly.net,被墙了 解决方法 我这边的的解决方法是更改github的hosts快速更改MacHosts 然后访问IPAddress.com根据域名找到本来的IP 更改Mac的hosts5.3发布到github上 编辑全局配置文件_config.yml，找到deploy的部分，设置github的项目地址 deploy: type: git repo: github:git@github.com:pvpheropvphero.github.io.git,master 接下来使用hexo命令部署 $ hexo d 如果出现 123 &#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; 这样的错误 输入命令行 $ npm install hexo --no-optional Hexo常见问题解决方案 这样自己的博客就部署到github上了.可以通过 username.github.io查看最后的效果 更换主题6.1找一个皮肤 比如我用的皮肤是spfk,下载下来后直接复制到/nodejs-blog/themes/里面 6.2_config.yml中设置皮肤 编辑文件_config.yml，找到theme一行，改成 theme: pacman 整个Hexo搭建个人博客就结束了.当然大家还可以个性化设置自己的博客主题,以及加载更多的Hexo插件.下一篇将会讲如何将博客同时部署到github上跟coding上.敬请期待~ CodingBlog GitHubBlog","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://pvphero.github.io/categories/Hexo/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://pvphero.github.io/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://pvphero.github.io/tags/Hexo/"},{"name":"Mac","slug":"Mac","permalink":"http://pvphero.github.io/tags/Mac/"},{"name":"Blog","slug":"Blog","permalink":"http://pvphero.github.io/tags/Blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-04-23T18:56:46.000Z","updated":"2016-04-23T18:56:46.000Z","comments":true,"path":"2016/04/24/hello-world/","link":"","permalink":"http://pvphero.github.io/2016/04/24/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}